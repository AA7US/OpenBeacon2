
OpenBeaconMini.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001086  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000057  00800060  00800060  0000111a  2**0
                  ALLOC
  2 .eeprom       0000002b  00810000  00810000  0000111a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .stab         000019b0  00000000  00000000  00001148  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000da1  00000000  00000000  00002af8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00003899  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	33 c0       	rjmp	.+102    	; 0x68 <__ctors_end>
       2:	42 c0       	rjmp	.+132    	; 0x88 <__bad_interrupt>
       4:	41 c0       	rjmp	.+130    	; 0x88 <__bad_interrupt>
       6:	40 c0       	rjmp	.+128    	; 0x88 <__bad_interrupt>
       8:	3f c0       	rjmp	.+126    	; 0x88 <__bad_interrupt>
       a:	3e c0       	rjmp	.+124    	; 0x88 <__bad_interrupt>
       c:	3d c0       	rjmp	.+122    	; 0x88 <__bad_interrupt>
       e:	3c c0       	rjmp	.+120    	; 0x88 <__bad_interrupt>
      10:	3b c0       	rjmp	.+118    	; 0x88 <__bad_interrupt>
      12:	3a c0       	rjmp	.+116    	; 0x88 <__bad_interrupt>
      14:	3a c0       	rjmp	.+116    	; 0x8a <__vector_10>
      16:	38 c0       	rjmp	.+112    	; 0x88 <__bad_interrupt>
      18:	37 c0       	rjmp	.+110    	; 0x88 <__bad_interrupt>
      1a:	36 c0       	rjmp	.+108    	; 0x88 <__bad_interrupt>
      1c:	35 c0       	rjmp	.+106    	; 0x88 <__bad_interrupt>

0000001e <morsechar>:
      1e:	ff 80 80 80 80 80 80 80 80 80 80 80 80 e0 80 94     ................
      2e:	fc 7c 3c 1c 0c 04 84 c4 e4 f4 80 80 80 8c 80 32     .|<............2
      3e:	80 60 88 a8 90 40 28 d0 08 20 78 b0 48 e0 a0 f0     .`...@(.. x.H...
      4e:	68 d8 50 10 c0 30 18 70 98 b8 c8                    h.P..0.p...

00000059 <hell_tune>:
      59:	fc b9 8c 55 35 17 00                                ...U5..

00000060 <dit_speed>:
      60:	c8 00 c8 00 98 3a 10 27                             .....:.'

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf e5       	ldi	r28, 0x5F	; 95
      6e:	d1 e0       	ldi	r29, 0x01	; 1
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_clear_bss>:
      74:	10 e0       	ldi	r17, 0x00	; 0
      76:	a0 e6       	ldi	r26, 0x60	; 96
      78:	b0 e0       	ldi	r27, 0x00	; 0
      7a:	01 c0       	rjmp	.+2      	; 0x7e <.do_clear_bss_start>

0000007c <.do_clear_bss_loop>:
      7c:	1d 92       	st	X+, r1

0000007e <.do_clear_bss_start>:
      7e:	a7 3b       	cpi	r26, 0xB7	; 183
      80:	b1 07       	cpc	r27, r17
      82:	e1 f7       	brne	.-8      	; 0x7c <.do_clear_bss_loop>
      84:	18 d2       	rcall	.+1072   	; 0x4b6 <main>
      86:	fd c7       	rjmp	.+4090   	; 0x1082 <_exit>

00000088 <__bad_interrupt>:
      88:	bb cf       	rjmp	.-138    	; 0x0 <__vectors>

0000008a <__vector_10>:
void tx_on(void);
void tx_off(void);

// Interrupt service routine
ISR(TIM0_COMPA_vect)
{
      8a:	1f 92       	push	r1
      8c:	0f 92       	push	r0
      8e:	00 90 5f 00 	lds	r0, 0x005F
      92:	0f 92       	push	r0
      94:	11 24       	eor	r1, r1
      96:	2f 93       	push	r18
      98:	3f 93       	push	r19
      9a:	4f 93       	push	r20
      9c:	5f 93       	push	r21
      9e:	6f 93       	push	r22
      a0:	7f 93       	push	r23
      a2:	8f 93       	push	r24
      a4:	9f 93       	push	r25
      a6:	af 93       	push	r26
      a8:	bf 93       	push	r27
      aa:	ef 93       	push	r30
      ac:	ff 93       	push	r31
      ae:	cf 93       	push	r28
      b0:	df 93       	push	r29
      b2:	cd b7       	in	r28, 0x3d	; 61
      b4:	de b7       	in	r29, 0x3e	; 62
	// Tick the clock
	timer++;
      b6:	80 91 94 00 	lds	r24, 0x0094
      ba:	90 91 95 00 	lds	r25, 0x0095
      be:	a0 91 96 00 	lds	r26, 0x0096
      c2:	b0 91 97 00 	lds	r27, 0x0097
      c6:	01 96       	adiw	r24, 0x01	; 1
      c8:	a1 1d       	adc	r26, r1
      ca:	b1 1d       	adc	r27, r1
      cc:	80 93 94 00 	sts	0x0094, r24
      d0:	90 93 95 00 	sts	0x0095, r25
      d4:	a0 93 96 00 	sts	0x0096, r26
      d8:	b0 93 97 00 	sts	0x0097, r27

	debounce();
      dc:	c6 d0       	rcall	.+396    	; 0x26a <debounce>
}
      de:	df 91       	pop	r29
      e0:	cf 91       	pop	r28
      e2:	ff 91       	pop	r31
      e4:	ef 91       	pop	r30
      e6:	bf 91       	pop	r27
      e8:	af 91       	pop	r26
      ea:	9f 91       	pop	r25
      ec:	8f 91       	pop	r24
      ee:	7f 91       	pop	r23
      f0:	6f 91       	pop	r22
      f2:	5f 91       	pop	r21
      f4:	4f 91       	pop	r20
      f6:	3f 91       	pop	r19
      f8:	2f 91       	pop	r18
      fa:	0f 90       	pop	r0
      fc:	00 92 5f 00 	sts	0x005F, r0
     100:	0f 90       	pop	r0
     102:	1f 90       	pop	r1
     104:	18 95       	reti

00000106 <set_wpm>:

void set_wpm(uint32_t new_wpm)
{
     106:	cf 93       	push	r28
     108:	df 93       	push	r29
     10a:	00 d0       	rcall	.+0      	; 0x10c <set_wpm+0x6>
     10c:	00 d0       	rcall	.+0      	; 0x10e <set_wpm+0x8>
     10e:	cd b7       	in	r28, 0x3d	; 61
     110:	de b7       	in	r29, 0x3e	; 62
     112:	69 83       	std	Y+1, r22	; 0x01
     114:	7a 83       	std	Y+2, r23	; 0x02
     116:	8b 83       	std	Y+3, r24	; 0x03
     118:	9c 83       	std	Y+4, r25	; 0x04
	// This is WPM * 1000 due to need for fractional WPM for slow modes
	//
	// Dit length in milliseconds is 1200 ms / WPM
	// Divide by 2 ms to get number of timer ticks
	dit_length = (1200000L / new_wpm) / 2;
     11a:	80 ec       	ldi	r24, 0xC0	; 192
     11c:	97 e2       	ldi	r25, 0x27	; 39
     11e:	a9 e0       	ldi	r26, 0x09	; 9
     120:	b0 e0       	ldi	r27, 0x00	; 0
     122:	29 81       	ldd	r18, Y+1	; 0x01
     124:	3a 81       	ldd	r19, Y+2	; 0x02
     126:	4b 81       	ldd	r20, Y+3	; 0x03
     128:	5c 81       	ldd	r21, Y+4	; 0x04
     12a:	bc 01       	movw	r22, r24
     12c:	cd 01       	movw	r24, r26
     12e:	6d d7       	rcall	.+3802   	; 0x100a <__udivmodsi4>
     130:	da 01       	movw	r26, r20
     132:	c9 01       	movw	r24, r18
     134:	80 93 99 00 	sts	0x0099, r24
     138:	90 93 9a 00 	sts	0x009A, r25
     13c:	a0 93 9b 00 	sts	0x009B, r26
     140:	b0 93 9c 00 	sts	0x009C, r27
}
     144:	0f 90       	pop	r0
     146:	0f 90       	pop	r0
     148:	0f 90       	pop	r0
     14a:	0f 90       	pop	r0
     14c:	df 91       	pop	r29
     14e:	cf 91       	pop	r28
     150:	08 95       	ret

00000152 <get_msg_delay>:

uint32_t get_msg_delay(uint8_t delay_minutes)
{
     152:	cf 93       	push	r28
     154:	df 93       	push	r29
     156:	1f 92       	push	r1
     158:	cd b7       	in	r28, 0x3d	; 61
     15a:	de b7       	in	r29, 0x3e	; 62
     15c:	89 83       	std	Y+1, r24	; 0x01
	// Number of clock ticks is the number of minutes * 29978 ticks/per min  --63?
	return (uint32_t)delay_minutes * 29978L;
     15e:	89 81       	ldd	r24, Y+1	; 0x01
     160:	88 2f       	mov	r24, r24
     162:	90 e0       	ldi	r25, 0x00	; 0
     164:	a0 e0       	ldi	r26, 0x00	; 0
     166:	b0 e0       	ldi	r27, 0x00	; 0
     168:	2a e1       	ldi	r18, 0x1A	; 26
     16a:	35 e7       	ldi	r19, 0x75	; 117
     16c:	40 e0       	ldi	r20, 0x00	; 0
     16e:	50 e0       	ldi	r21, 0x00	; 0
     170:	bc 01       	movw	r22, r24
     172:	cd 01       	movw	r24, r26
     174:	31 d7       	rcall	.+3682   	; 0xfd8 <__mulsi3>
     176:	dc 01       	movw	r26, r24
     178:	cb 01       	movw	r24, r22
}
     17a:	bc 01       	movw	r22, r24
     17c:	cd 01       	movw	r24, r26
     17e:	0f 90       	pop	r0
     180:	df 91       	pop	r29
     182:	cf 91       	pop	r28
     184:	08 95       	ret

00000186 <init_tx>:

void init_tx(void)
{
     186:	ef 92       	push	r14
     188:	ff 92       	push	r15
     18a:	0f 93       	push	r16
     18c:	1f 93       	push	r17
     18e:	cf 93       	push	r28
     190:	df 93       	push	r29
     192:	00 d0       	rcall	.+0      	; 0x194 <init_tx+0xe>
     194:	00 d0       	rcall	.+0      	; 0x196 <init_tx+0x10>
     196:	cd b7       	in	r28, 0x3d	; 61
     198:	de b7       	in	r29, 0x3e	; 62
	// Reset the message buffer
	reset_buffer();
     19a:	cb d0       	rcall	.+406    	; 0x332 <reset_buffer>

	// If in message delay mode, set the delay
	msg_delay_end = cur_timer + get_msg_delay(msg_delay);
     19c:	80 91 a6 00 	lds	r24, 0x00A6
     1a0:	d8 df       	rcall	.-80     	; 0x152 <get_msg_delay>
     1a2:	9b 01       	movw	r18, r22
     1a4:	ac 01       	movw	r20, r24
     1a6:	80 91 60 00 	lds	r24, 0x0060
     1aa:	90 91 61 00 	lds	r25, 0x0061
     1ae:	a0 91 62 00 	lds	r26, 0x0062
     1b2:	b0 91 63 00 	lds	r27, 0x0063
     1b6:	82 0f       	add	r24, r18
     1b8:	93 1f       	adc	r25, r19
     1ba:	a4 1f       	adc	r26, r20
     1bc:	b5 1f       	adc	r27, r21
     1be:	80 93 90 00 	sts	0x0090, r24
     1c2:	90 93 91 00 	sts	0x0091, r25
     1c6:	a0 93 92 00 	sts	0x0092, r26
     1ca:	b0 93 93 00 	sts	0x0093, r27

	// Reset WPM
	if(cur_mode == MODE_CW)
     1ce:	80 91 9d 00 	lds	r24, 0x009D
     1d2:	82 30       	cpi	r24, 0x02	; 2
     1d4:	41 f4       	brne	.+16     	; 0x1e6 <init_tx+0x60>
		wpm = eeprom_read_word(&ee_wpm);
     1d6:	80 e0       	ldi	r24, 0x00	; 0
     1d8:	90 e0       	ldi	r25, 0x00	; 0
     1da:	4f d7       	rcall	.+3742   	; 0x107a <__eerd_word_tn45>
     1dc:	90 93 ac 00 	sts	0x00AC, r25
     1e0:	80 93 ab 00 	sts	0x00AB, r24
     1e4:	1b c0       	rjmp	.+54     	; 0x21c <init_tx+0x96>
	else
		wpm = pgm_read_word(&dit_speed[cur_mode]);
     1e6:	80 91 9d 00 	lds	r24, 0x009D
     1ea:	88 2f       	mov	r24, r24
     1ec:	90 e0       	ldi	r25, 0x00	; 0
     1ee:	88 0f       	add	r24, r24
     1f0:	99 1f       	adc	r25, r25
     1f2:	80 5a       	subi	r24, 0xA0	; 160
     1f4:	9f 4f       	sbci	r25, 0xFF	; 255
     1f6:	9a 83       	std	Y+2, r25	; 0x02
     1f8:	89 83       	std	Y+1, r24	; 0x01
     1fa:	89 81       	ldd	r24, Y+1	; 0x01
     1fc:	9a 81       	ldd	r25, Y+2	; 0x02
     1fe:	8c 01       	movw	r16, r24
     200:	f8 01       	movw	r30, r16
     202:	e5 90       	lpm	r14, Z+
     204:	f4 90       	lpm	r15, Z+
     206:	8f 01       	movw	r16, r30
     208:	fc 82       	std	Y+4, r15	; 0x04
     20a:	eb 82       	std	Y+3, r14	; 0x03
     20c:	1a 83       	std	Y+2, r17	; 0x02
     20e:	09 83       	std	Y+1, r16	; 0x01
     210:	8b 81       	ldd	r24, Y+3	; 0x03
     212:	9c 81       	ldd	r25, Y+4	; 0x04
     214:	90 93 ac 00 	sts	0x00AC, r25
     218:	80 93 ab 00 	sts	0x00AB, r24
	set_wpm(wpm);
     21c:	80 91 ab 00 	lds	r24, 0x00AB
     220:	90 91 ac 00 	lds	r25, 0x00AC
     224:	cc 01       	movw	r24, r24
     226:	a0 e0       	ldi	r26, 0x00	; 0
     228:	b0 e0       	ldi	r27, 0x00	; 0
     22a:	bc 01       	movw	r22, r24
     22c:	cd 01       	movw	r24, r26
     22e:	6b df       	rcall	.-298    	; 0x106 <set_wpm>


	// Reset to IDLE state
	cur_state_end = cur_timer;
     230:	80 91 60 00 	lds	r24, 0x0060
     234:	90 91 61 00 	lds	r25, 0x0061
     238:	a0 91 62 00 	lds	r26, 0x0062
     23c:	b0 91 63 00 	lds	r27, 0x0063
     240:	80 93 a7 00 	sts	0x00A7, r24
     244:	90 93 a8 00 	sts	0x00A8, r25
     248:	a0 93 a9 00 	sts	0x00A9, r26
     24c:	b0 93 aa 00 	sts	0x00AA, r27
	cur_state = STATE_IDLE;
     250:	10 92 a3 00 	sts	0x00A3, r1
}
     254:	0f 90       	pop	r0
     256:	0f 90       	pop	r0
     258:	0f 90       	pop	r0
     25a:	0f 90       	pop	r0
     25c:	df 91       	pop	r29
     25e:	cf 91       	pop	r28
     260:	1f 91       	pop	r17
     262:	0f 91       	pop	r16
     264:	ff 90       	pop	r15
     266:	ef 90       	pop	r14
     268:	08 95       	ret

0000026a <debounce>:

void debounce(void)
{
     26a:	cf 93       	push	r28
     26c:	df 93       	push	r29
     26e:	00 d0       	rcall	.+0      	; 0x270 <debounce+0x6>
     270:	1f 92       	push	r1
     272:	cd b7       	in	r28, 0x3d	; 61
     274:	de b7       	in	r29, 0x3e	; 62
	enum BOOL S1_active, S2_active, S3_active;

	S1_active = bit_is_clear(S1_PIN, S1);
     276:	86 e3       	ldi	r24, 0x36	; 54
     278:	90 e0       	ldi	r25, 0x00	; 0
     27a:	fc 01       	movw	r30, r24
     27c:	80 81       	ld	r24, Z
     27e:	88 2f       	mov	r24, r24
     280:	90 e0       	ldi	r25, 0x00	; 0
     282:	81 70       	andi	r24, 0x01	; 1
     284:	99 27       	eor	r25, r25
     286:	21 e0       	ldi	r18, 0x01	; 1
     288:	00 97       	sbiw	r24, 0x00	; 0
     28a:	09 f0       	breq	.+2      	; 0x28e <debounce+0x24>
     28c:	20 e0       	ldi	r18, 0x00	; 0
     28e:	29 83       	std	Y+1, r18	; 0x01
	S2_active = bit_is_clear(S2_PIN, S2);
     290:	86 e3       	ldi	r24, 0x36	; 54
     292:	90 e0       	ldi	r25, 0x00	; 0
     294:	fc 01       	movw	r30, r24
     296:	80 81       	ld	r24, Z
     298:	88 2f       	mov	r24, r24
     29a:	90 e0       	ldi	r25, 0x00	; 0
     29c:	82 70       	andi	r24, 0x02	; 2
     29e:	99 27       	eor	r25, r25
     2a0:	21 e0       	ldi	r18, 0x01	; 1
     2a2:	00 97       	sbiw	r24, 0x00	; 0
     2a4:	09 f0       	breq	.+2      	; 0x2a8 <debounce+0x3e>
     2a6:	20 e0       	ldi	r18, 0x00	; 0
     2a8:	2a 83       	std	Y+2, r18	; 0x02
	S3_active = bit_is_clear(S3_PIN, S3);
     2aa:	86 e3       	ldi	r24, 0x36	; 54
     2ac:	90 e0       	ldi	r25, 0x00	; 0
     2ae:	fc 01       	movw	r30, r24
     2b0:	80 81       	ld	r24, Z
     2b2:	88 2f       	mov	r24, r24
     2b4:	90 e0       	ldi	r25, 0x00	; 0
     2b6:	84 70       	andi	r24, 0x04	; 4
     2b8:	99 27       	eor	r25, r25
     2ba:	21 e0       	ldi	r18, 0x01	; 1
     2bc:	00 97       	sbiw	r24, 0x00	; 0
     2be:	09 f0       	breq	.+2      	; 0x2c2 <debounce+0x58>
     2c0:	20 e0       	ldi	r18, 0x00	; 0
     2c2:	2b 83       	std	Y+3, r18	; 0x03

	// Set mode
	if((!S1_active) && (!S2_active))
     2c4:	89 81       	ldd	r24, Y+1	; 0x01
     2c6:	88 23       	and	r24, r24
     2c8:	31 f4       	brne	.+12     	; 0x2d6 <debounce+0x6c>
     2ca:	8a 81       	ldd	r24, Y+2	; 0x02
     2cc:	88 23       	and	r24, r24
     2ce:	19 f4       	brne	.+6      	; 0x2d6 <debounce+0x6c>
		cur_mode = MODE_DFCW6;
     2d0:	10 92 9d 00 	sts	0x009D, r1
     2d4:	1c c0       	rjmp	.+56     	; 0x30e <debounce+0xa4>
	else if((S1_active) && (!S2_active))
     2d6:	89 81       	ldd	r24, Y+1	; 0x01
     2d8:	88 23       	and	r24, r24
     2da:	39 f0       	breq	.+14     	; 0x2ea <debounce+0x80>
     2dc:	8a 81       	ldd	r24, Y+2	; 0x02
     2de:	88 23       	and	r24, r24
     2e0:	21 f4       	brne	.+8      	; 0x2ea <debounce+0x80>
		cur_mode = MODE_QRSS6;
     2e2:	81 e0       	ldi	r24, 0x01	; 1
     2e4:	80 93 9d 00 	sts	0x009D, r24
     2e8:	12 c0       	rjmp	.+36     	; 0x30e <debounce+0xa4>
	else if((!S1_active) && (S2_active))
     2ea:	89 81       	ldd	r24, Y+1	; 0x01
     2ec:	88 23       	and	r24, r24
     2ee:	31 f4       	brne	.+12     	; 0x2fc <debounce+0x92>
     2f0:	8a 81       	ldd	r24, Y+2	; 0x02
     2f2:	88 23       	and	r24, r24
     2f4:	19 f0       	breq	.+6      	; 0x2fc <debounce+0x92>
		cur_mode = MODE_DFCW6; //Need a new mode here
     2f6:	10 92 9d 00 	sts	0x009D, r1
     2fa:	09 c0       	rjmp	.+18     	; 0x30e <debounce+0xa4>
	else if((S1_active) && (S2_active))
     2fc:	89 81       	ldd	r24, Y+1	; 0x01
     2fe:	88 23       	and	r24, r24
     300:	31 f0       	breq	.+12     	; 0x30e <debounce+0xa4>
     302:	8a 81       	ldd	r24, Y+2	; 0x02
     304:	88 23       	and	r24, r24
     306:	19 f0       	breq	.+6      	; 0x30e <debounce+0xa4>
		cur_mode = MODE_CAL;
     308:	83 e0       	ldi	r24, 0x03	; 3
     30a:	80 93 9d 00 	sts	0x009D, r24

	// Set message delay
	if(!S3_active)
     30e:	8b 81       	ldd	r24, Y+3	; 0x03
     310:	88 23       	and	r24, r24
     312:	19 f4       	brne	.+6      	; 0x31a <debounce+0xb0>
		msg_delay = 0;
     314:	10 92 a6 00 	sts	0x00A6, r1
     318:	06 c0       	rjmp	.+12     	; 0x326 <debounce+0xbc>
	else if(S3_active)
     31a:	8b 81       	ldd	r24, Y+3	; 0x03
     31c:	88 23       	and	r24, r24
     31e:	19 f0       	breq	.+6      	; 0x326 <debounce+0xbc>
		msg_delay = MSG_DELAY;
     320:	8a e0       	ldi	r24, 0x0A	; 10
     322:	80 93 a6 00 	sts	0x00A6, r24
}
     326:	0f 90       	pop	r0
     328:	0f 90       	pop	r0
     32a:	0f 90       	pop	r0
     32c:	df 91       	pop	r29
     32e:	cf 91       	pop	r28
     330:	08 95       	ret

00000332 <reset_buffer>:

void reset_buffer(void)
{
     332:	cf 93       	push	r28
     334:	df 93       	push	r29
     336:	cd b7       	in	r28, 0x3d	; 61
     338:	de b7       	in	r29, 0x3e	; 62
	memset(msg_buffer, '\0', MSG_BUFFER_SIZE);
     33a:	49 e2       	ldi	r20, 0x29	; 41
     33c:	50 e0       	ldi	r21, 0x00	; 0
     33e:	60 e0       	ldi	r22, 0x00	; 0
     340:	70 e0       	ldi	r23, 0x00	; 0
     342:	87 e6       	ldi	r24, 0x67	; 103
     344:	90 e0       	ldi	r25, 0x00	; 0
     346:	83 d6       	rcall	.+3334   	; 0x104e <memset>
	eeprom_read_block((void*)&msg_buffer, (const void*)&ee_msg_mem, MSG_BUFFER_SIZE - 1);
     348:	48 e2       	ldi	r20, 0x28	; 40
     34a:	50 e0       	ldi	r21, 0x00	; 0
     34c:	62 e0       	ldi	r22, 0x02	; 2
     34e:	70 e0       	ldi	r23, 0x00	; 0
     350:	87 e6       	ldi	r24, 0x67	; 103
     352:	90 e0       	ldi	r25, 0x00	; 0
     354:	83 d6       	rcall	.+3334   	; 0x105c <__eerd_block_tn45>
	cur_msg_p = msg_buffer;
     356:	87 e6       	ldi	r24, 0x67	; 103
     358:	90 e0       	ldi	r25, 0x00	; 0
     35a:	90 93 b6 00 	sts	0x00B6, r25
     35e:	80 93 b5 00 	sts	0x00B5, r24
	cur_character = '\0';
     362:	10 92 64 00 	sts	0x0064, r1
}
     366:	df 91       	pop	r29
     368:	cf 91       	pop	r28
     36a:	08 95       	ret

0000036c <init_cwid>:

void init_cwid(void)
{
     36c:	cf 93       	push	r28
     36e:	df 93       	push	r29
     370:	cd b7       	in	r28, 0x3d	; 61
     372:	de b7       	in	r29, 0x3e	; 62
	cwid = TRUE;
     374:	81 e0       	ldi	r24, 0x01	; 1
     376:	80 93 66 00 	sts	0x0066, r24
	prev_mode = cur_mode;
     37a:	80 91 9d 00 	lds	r24, 0x009D
     37e:	80 93 a2 00 	sts	0x00A2, r24
	prev_wpm = wpm;
     382:	80 91 ab 00 	lds	r24, 0x00AB
     386:	90 91 ac 00 	lds	r25, 0x00AC
     38a:	90 93 b4 00 	sts	0x00B4, r25
     38e:	80 93 b3 00 	sts	0x00B3, r24
	prev_character = cur_character;
     392:	80 91 64 00 	lds	r24, 0x0064
     396:	80 93 65 00 	sts	0x0065, r24
	prev_msg_p = cur_msg_p;
     39a:	80 91 b5 00 	lds	r24, 0x00B5
     39e:	90 91 b6 00 	lds	r25, 0x00B6
     3a2:	90 93 ae 00 	sts	0x00AE, r25
     3a6:	80 93 ad 00 	sts	0x00AD, r24
	prev_state_end = cur_state_end;
     3aa:	80 91 a7 00 	lds	r24, 0x00A7
     3ae:	90 91 a8 00 	lds	r25, 0x00A8
     3b2:	a0 91 a9 00 	lds	r26, 0x00A9
     3b6:	b0 91 aa 00 	lds	r27, 0x00AA
     3ba:	80 93 9e 00 	sts	0x009E, r24
     3be:	90 93 9f 00 	sts	0x009F, r25
     3c2:	a0 93 a0 00 	sts	0x00A0, r26
     3c6:	b0 93 a1 00 	sts	0x00A1, r27
	prev_state = cur_state;
     3ca:	80 91 a3 00 	lds	r24, 0x00A3
     3ce:	80 93 98 00 	sts	0x0098, r24

	cur_mode = MODE_CW;
     3d2:	82 e0       	ldi	r24, 0x02	; 2
     3d4:	80 93 9d 00 	sts	0x009D, r24
	wpm = CWID_WPM;
     3d8:	80 e2       	ldi	r24, 0x20	; 32
     3da:	9e e4       	ldi	r25, 0x4E	; 78
     3dc:	90 93 ac 00 	sts	0x00AC, r25
     3e0:	80 93 ab 00 	sts	0x00AB, r24
	set_wpm(wpm);
     3e4:	80 91 ab 00 	lds	r24, 0x00AB
     3e8:	90 91 ac 00 	lds	r25, 0x00AC
     3ec:	cc 01       	movw	r24, r24
     3ee:	a0 e0       	ldi	r26, 0x00	; 0
     3f0:	b0 e0       	ldi	r27, 0x00	; 0
     3f2:	bc 01       	movw	r22, r24
     3f4:	cd 01       	movw	r24, r26
     3f6:	87 de       	rcall	.-754    	; 0x106 <set_wpm>
	reset_buffer();
     3f8:	9c df       	rcall	.-200    	; 0x332 <reset_buffer>

	// Give a DAH delay w/ TX off so we can properly distinguish CW from QRSS
	cur_state_end = cur_timer + (dit_length * MULT_DAH);
     3fa:	20 91 99 00 	lds	r18, 0x0099
     3fe:	30 91 9a 00 	lds	r19, 0x009A
     402:	40 91 9b 00 	lds	r20, 0x009B
     406:	50 91 9c 00 	lds	r21, 0x009C
     40a:	da 01       	movw	r26, r20
     40c:	c9 01       	movw	r24, r18
     40e:	88 0f       	add	r24, r24
     410:	99 1f       	adc	r25, r25
     412:	aa 1f       	adc	r26, r26
     414:	bb 1f       	adc	r27, r27
     416:	28 0f       	add	r18, r24
     418:	39 1f       	adc	r19, r25
     41a:	4a 1f       	adc	r20, r26
     41c:	5b 1f       	adc	r21, r27
     41e:	80 91 60 00 	lds	r24, 0x0060
     422:	90 91 61 00 	lds	r25, 0x0061
     426:	a0 91 62 00 	lds	r26, 0x0062
     42a:	b0 91 63 00 	lds	r27, 0x0063
     42e:	82 0f       	add	r24, r18
     430:	93 1f       	adc	r25, r19
     432:	a4 1f       	adc	r26, r20
     434:	b5 1f       	adc	r27, r21
     436:	80 93 a7 00 	sts	0x00A7, r24
     43a:	90 93 a8 00 	sts	0x00A8, r25
     43e:	a0 93 a9 00 	sts	0x00A9, r26
     442:	b0 93 aa 00 	sts	0x00AA, r27
	cur_state = STATE_DAHDELAY;
     446:	84 e0       	ldi	r24, 0x04	; 4
     448:	80 93 a3 00 	sts	0x00A3, r24
}
     44c:	df 91       	pop	r29
     44e:	cf 91       	pop	r28
     450:	08 95       	ret

00000452 <tx_on>:

void tx_on(void)
{
     452:	cf 93       	push	r28
     454:	df 93       	push	r29
     456:	cd b7       	in	r28, 0x3d	; 61
     458:	de b7       	in	r29, 0x3e	; 62
	KEY_DDR |= _BV(KEY);
     45a:	87 e3       	ldi	r24, 0x37	; 55
     45c:	90 e0       	ldi	r25, 0x00	; 0
     45e:	27 e3       	ldi	r18, 0x37	; 55
     460:	30 e0       	ldi	r19, 0x00	; 0
     462:	f9 01       	movw	r30, r18
     464:	20 81       	ld	r18, Z
     466:	28 60       	ori	r18, 0x08	; 8
     468:	fc 01       	movw	r30, r24
     46a:	20 83       	st	Z, r18
	KEY_PORT &= ~(_BV(KEY));
     46c:	88 e3       	ldi	r24, 0x38	; 56
     46e:	90 e0       	ldi	r25, 0x00	; 0
     470:	28 e3       	ldi	r18, 0x38	; 56
     472:	30 e0       	ldi	r19, 0x00	; 0
     474:	f9 01       	movw	r30, r18
     476:	20 81       	ld	r18, Z
     478:	27 7f       	andi	r18, 0xF7	; 247
     47a:	fc 01       	movw	r30, r24
     47c:	20 83       	st	Z, r18
}
     47e:	df 91       	pop	r29
     480:	cf 91       	pop	r28
     482:	08 95       	ret

00000484 <tx_off>:

void tx_off(void)
{
     484:	cf 93       	push	r28
     486:	df 93       	push	r29
     488:	cd b7       	in	r28, 0x3d	; 61
     48a:	de b7       	in	r29, 0x3e	; 62
	KEY_DDR &= ~(_BV(KEY));
     48c:	87 e3       	ldi	r24, 0x37	; 55
     48e:	90 e0       	ldi	r25, 0x00	; 0
     490:	27 e3       	ldi	r18, 0x37	; 55
     492:	30 e0       	ldi	r19, 0x00	; 0
     494:	f9 01       	movw	r30, r18
     496:	20 81       	ld	r18, Z
     498:	27 7f       	andi	r18, 0xF7	; 247
     49a:	fc 01       	movw	r30, r24
     49c:	20 83       	st	Z, r18
	KEY_PORT &= ~(_BV(KEY));
     49e:	88 e3       	ldi	r24, 0x38	; 56
     4a0:	90 e0       	ldi	r25, 0x00	; 0
     4a2:	28 e3       	ldi	r18, 0x38	; 56
     4a4:	30 e0       	ldi	r19, 0x00	; 0
     4a6:	f9 01       	movw	r30, r18
     4a8:	20 81       	ld	r18, Z
     4aa:	27 7f       	andi	r18, 0xF7	; 247
     4ac:	fc 01       	movw	r30, r24
     4ae:	20 83       	st	Z, r18
}
     4b0:	df 91       	pop	r29
     4b2:	cf 91       	pop	r28
     4b4:	08 95       	ret

000004b6 <main>:

int main(void)
{
     4b6:	ef 92       	push	r14
     4b8:	ff 92       	push	r15
     4ba:	0f 93       	push	r16
     4bc:	1f 93       	push	r17
     4be:	cf 93       	push	r28
     4c0:	df 93       	push	r29
     4c2:	cd b7       	in	r28, 0x3d	; 61
     4c4:	de b7       	in	r29, 0x3e	; 62
     4c6:	2a 97       	sbiw	r28, 0x0a	; 10
     4c8:	0f b6       	in	r0, 0x3f	; 63
     4ca:	f8 94       	cli
     4cc:	de bf       	out	0x3e, r29	; 62
     4ce:	0f be       	out	0x3f, r0	; 63
     4d0:	cd bf       	out	0x3d, r28	; 61
	// Set up Timer0 for event timer
	// 16.5 MHz clock, /256 prescale, 125 count = 1 ms timer interrupt
	TCCR0A |= _BV(WGM01); // CTC mode
     4d2:	8a e4       	ldi	r24, 0x4A	; 74
     4d4:	90 e0       	ldi	r25, 0x00	; 0
     4d6:	2a e4       	ldi	r18, 0x4A	; 74
     4d8:	30 e0       	ldi	r19, 0x00	; 0
     4da:	f9 01       	movw	r30, r18
     4dc:	20 81       	ld	r18, Z
     4de:	22 60       	ori	r18, 0x02	; 2
     4e0:	fc 01       	movw	r30, r24
     4e2:	20 83       	st	Z, r18
	TCCR0B = _BV(CS01); // Prescale /8, gives 8 us clock tick
     4e4:	83 e5       	ldi	r24, 0x53	; 83
     4e6:	90 e0       	ldi	r25, 0x00	; 0
     4e8:	22 e0       	ldi	r18, 0x02	; 2
     4ea:	fc 01       	movw	r30, r24
     4ec:	20 83       	st	Z, r18
	OCR0A = 124;
     4ee:	89 e4       	ldi	r24, 0x49	; 73
     4f0:	90 e0       	ldi	r25, 0x00	; 0
     4f2:	2c e7       	ldi	r18, 0x7C	; 124
     4f4:	fc 01       	movw	r30, r24
     4f6:	20 83       	st	Z, r18
	TIMSK |= _BV(OCIE0A); // Enable CTC interrupt
     4f8:	89 e5       	ldi	r24, 0x59	; 89
     4fa:	90 e0       	ldi	r25, 0x00	; 0
     4fc:	29 e5       	ldi	r18, 0x59	; 89
     4fe:	30 e0       	ldi	r19, 0x00	; 0
     500:	f9 01       	movw	r30, r18
     502:	20 81       	ld	r18, Z
     504:	20 61       	ori	r18, 0x10	; 16
     506:	fc 01       	movw	r30, r24
     508:	20 83       	st	Z, r18
	OCR1C = 255;
	PLLCSR = _BV(PLLE) | _BV(PCKE);
	*/

	// Initialize ports
	FSK_DDR |= _BV(FSK);
     50a:	87 e3       	ldi	r24, 0x37	; 55
     50c:	90 e0       	ldi	r25, 0x00	; 0
     50e:	27 e3       	ldi	r18, 0x37	; 55
     510:	30 e0       	ldi	r19, 0x00	; 0
     512:	f9 01       	movw	r30, r18
     514:	20 81       	ld	r18, Z
     516:	20 61       	ori	r18, 0x10	; 16
     518:	fc 01       	movw	r30, r24
     51a:	20 83       	st	Z, r18
	FSK_PORT |= _BV(FSK);
     51c:	88 e3       	ldi	r24, 0x38	; 56
     51e:	90 e0       	ldi	r25, 0x00	; 0
     520:	28 e3       	ldi	r18, 0x38	; 56
     522:	30 e0       	ldi	r19, 0x00	; 0
     524:	f9 01       	movw	r30, r18
     526:	20 81       	ld	r18, Z
     528:	20 61       	ori	r18, 0x10	; 16
     52a:	fc 01       	movw	r30, r24
     52c:	20 83       	st	Z, r18

	KEY_DDR |= _BV(KEY);
     52e:	87 e3       	ldi	r24, 0x37	; 55
     530:	90 e0       	ldi	r25, 0x00	; 0
     532:	27 e3       	ldi	r18, 0x37	; 55
     534:	30 e0       	ldi	r19, 0x00	; 0
     536:	f9 01       	movw	r30, r18
     538:	20 81       	ld	r18, Z
     53a:	28 60       	ori	r18, 0x08	; 8
     53c:	fc 01       	movw	r30, r24
     53e:	20 83       	st	Z, r18
	KEY_PORT |= _BV(KEY);
     540:	88 e3       	ldi	r24, 0x38	; 56
     542:	90 e0       	ldi	r25, 0x00	; 0
     544:	28 e3       	ldi	r18, 0x38	; 56
     546:	30 e0       	ldi	r19, 0x00	; 0
     548:	f9 01       	movw	r30, r18
     54a:	20 81       	ld	r18, Z
     54c:	28 60       	ori	r18, 0x08	; 8
     54e:	fc 01       	movw	r30, r24
     550:	20 83       	st	Z, r18

	S1_DDR &= ~(_BV(S1));
     552:	87 e3       	ldi	r24, 0x37	; 55
     554:	90 e0       	ldi	r25, 0x00	; 0
     556:	27 e3       	ldi	r18, 0x37	; 55
     558:	30 e0       	ldi	r19, 0x00	; 0
     55a:	f9 01       	movw	r30, r18
     55c:	20 81       	ld	r18, Z
     55e:	2e 7f       	andi	r18, 0xFE	; 254
     560:	fc 01       	movw	r30, r24
     562:	20 83       	st	Z, r18
	S1_PORT |= _BV(S1); // Enable pull-up
     564:	88 e3       	ldi	r24, 0x38	; 56
     566:	90 e0       	ldi	r25, 0x00	; 0
     568:	28 e3       	ldi	r18, 0x38	; 56
     56a:	30 e0       	ldi	r19, 0x00	; 0
     56c:	f9 01       	movw	r30, r18
     56e:	20 81       	ld	r18, Z
     570:	21 60       	ori	r18, 0x01	; 1
     572:	fc 01       	movw	r30, r24
     574:	20 83       	st	Z, r18

	S2_DDR &= ~(_BV(S2));
     576:	87 e3       	ldi	r24, 0x37	; 55
     578:	90 e0       	ldi	r25, 0x00	; 0
     57a:	27 e3       	ldi	r18, 0x37	; 55
     57c:	30 e0       	ldi	r19, 0x00	; 0
     57e:	f9 01       	movw	r30, r18
     580:	20 81       	ld	r18, Z
     582:	2d 7f       	andi	r18, 0xFD	; 253
     584:	fc 01       	movw	r30, r24
     586:	20 83       	st	Z, r18
	S2_PORT |= _BV(S2); // Enable pull-up
     588:	88 e3       	ldi	r24, 0x38	; 56
     58a:	90 e0       	ldi	r25, 0x00	; 0
     58c:	28 e3       	ldi	r18, 0x38	; 56
     58e:	30 e0       	ldi	r19, 0x00	; 0
     590:	f9 01       	movw	r30, r18
     592:	20 81       	ld	r18, Z
     594:	22 60       	ori	r18, 0x02	; 2
     596:	fc 01       	movw	r30, r24
     598:	20 83       	st	Z, r18

	S3_DDR &= ~(_BV(S3));
     59a:	87 e3       	ldi	r24, 0x37	; 55
     59c:	90 e0       	ldi	r25, 0x00	; 0
     59e:	27 e3       	ldi	r18, 0x37	; 55
     5a0:	30 e0       	ldi	r19, 0x00	; 0
     5a2:	f9 01       	movw	r30, r18
     5a4:	20 81       	ld	r18, Z
     5a6:	2b 7f       	andi	r18, 0xFB	; 251
     5a8:	fc 01       	movw	r30, r24
     5aa:	20 83       	st	Z, r18
	S3_PORT |= _BV(S3); // Enable pull-up
     5ac:	88 e3       	ldi	r24, 0x38	; 56
     5ae:	90 e0       	ldi	r25, 0x00	; 0
     5b0:	28 e3       	ldi	r18, 0x38	; 56
     5b2:	30 e0       	ldi	r19, 0x00	; 0
     5b4:	f9 01       	movw	r30, r18
     5b6:	20 81       	ld	r18, Z
     5b8:	24 60       	ori	r18, 0x04	; 4
     5ba:	fc 01       	movw	r30, r24
     5bc:	20 83       	st	Z, r18

	//OCR1B = 255;

	// Transmitter off
	tx_off();
     5be:	62 df       	rcall	.-316    	; 0x484 <tx_off>

	// Set up the message buffer
	memset(msg_buffer, '\0', MSG_BUFFER_SIZE);
     5c0:	49 e2       	ldi	r20, 0x29	; 41
     5c2:	50 e0       	ldi	r21, 0x00	; 0
     5c4:	60 e0       	ldi	r22, 0x00	; 0
     5c6:	70 e0       	ldi	r23, 0x00	; 0
     5c8:	87 e6       	ldi	r24, 0x67	; 103
     5ca:	90 e0       	ldi	r25, 0x00	; 0
     5cc:	40 d5       	rcall	.+2688   	; 0x104e <memset>
	cur_msg_p = msg_buffer;
     5ce:	87 e6       	ldi	r24, 0x67	; 103
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	90 93 b6 00 	sts	0x00B6, r25
     5d6:	80 93 b5 00 	sts	0x00B5, r24

	// Initialize states
	cur_mode = MODE_DEFAULT;
     5da:	10 92 9d 00 	sts	0x009D, r1
	cur_state = STATE_IDLE;
     5de:	10 92 a3 00 	sts	0x00A3, r1

	if(cur_mode == MODE_CW)
     5e2:	80 91 9d 00 	lds	r24, 0x009D
     5e6:	82 30       	cpi	r24, 0x02	; 2
     5e8:	41 f4       	brne	.+16     	; 0x5fa <main+0x144>
		wpm = eeprom_read_word(&ee_wpm);
     5ea:	80 e0       	ldi	r24, 0x00	; 0
     5ec:	90 e0       	ldi	r25, 0x00	; 0
     5ee:	45 d5       	rcall	.+2698   	; 0x107a <__eerd_word_tn45>
     5f0:	90 93 ac 00 	sts	0x00AC, r25
     5f4:	80 93 ab 00 	sts	0x00AB, r24
     5f8:	1b c0       	rjmp	.+54     	; 0x630 <main+0x17a>
	else
		wpm = pgm_read_word(&dit_speed[cur_mode]);
     5fa:	80 91 9d 00 	lds	r24, 0x009D
     5fe:	88 2f       	mov	r24, r24
     600:	90 e0       	ldi	r25, 0x00	; 0
     602:	88 0f       	add	r24, r24
     604:	99 1f       	adc	r25, r25
     606:	80 5a       	subi	r24, 0xA0	; 160
     608:	9f 4f       	sbci	r25, 0xFF	; 255
     60a:	9a 83       	std	Y+2, r25	; 0x02
     60c:	89 83       	std	Y+1, r24	; 0x01
     60e:	89 81       	ldd	r24, Y+1	; 0x01
     610:	9a 81       	ldd	r25, Y+2	; 0x02
     612:	8c 01       	movw	r16, r24
     614:	f8 01       	movw	r30, r16
     616:	e5 90       	lpm	r14, Z+
     618:	f4 90       	lpm	r15, Z+
     61a:	8f 01       	movw	r16, r30
     61c:	fc 82       	std	Y+4, r15	; 0x04
     61e:	eb 82       	std	Y+3, r14	; 0x03
     620:	1a 83       	std	Y+2, r17	; 0x02
     622:	09 83       	std	Y+1, r16	; 0x01
     624:	8b 81       	ldd	r24, Y+3	; 0x03
     626:	9c 81       	ldd	r25, Y+4	; 0x04
     628:	90 93 ac 00 	sts	0x00AC, r25
     62c:	80 93 ab 00 	sts	0x00AB, r24
	set_wpm(wpm);
     630:	80 91 ab 00 	lds	r24, 0x00AB
     634:	90 91 ac 00 	lds	r25, 0x00AC
     638:	cc 01       	movw	r24, r24
     63a:	a0 e0       	ldi	r26, 0x00	; 0
     63c:	b0 e0       	ldi	r27, 0x00	; 0
     63e:	bc 01       	movw	r22, r24
     640:	cd 01       	movw	r24, r26
     642:	61 dd       	rcall	.-1342   	; 0x106 <set_wpm>

	eeprom_read_block((void*)&msg_buffer, (const void*)&ee_msg_mem, MSG_BUFFER_SIZE - 1);
     644:	48 e2       	ldi	r20, 0x28	; 40
     646:	50 e0       	ldi	r21, 0x00	; 0
     648:	62 e0       	ldi	r22, 0x02	; 2
     64a:	70 e0       	ldi	r23, 0x00	; 0
     64c:	87 e6       	ldi	r24, 0x67	; 103
     64e:	90 e0       	ldi	r25, 0x00	; 0
     650:	05 d5       	rcall	.+2570   	; 0x105c <__eerd_block_tn45>
	msg_delay_end = cur_timer + get_msg_delay(msg_delay);
     652:	80 91 a6 00 	lds	r24, 0x00A6
     656:	7d dd       	rcall	.-1286   	; 0x152 <get_msg_delay>
     658:	9b 01       	movw	r18, r22
     65a:	ac 01       	movw	r20, r24
     65c:	80 91 60 00 	lds	r24, 0x0060
     660:	90 91 61 00 	lds	r25, 0x0061
     664:	a0 91 62 00 	lds	r26, 0x0062
     668:	b0 91 63 00 	lds	r27, 0x0063
     66c:	82 0f       	add	r24, r18
     66e:	93 1f       	adc	r25, r19
     670:	a4 1f       	adc	r26, r20
     672:	b5 1f       	adc	r27, r21
     674:	80 93 90 00 	sts	0x0090, r24
     678:	90 93 91 00 	sts	0x0091, r25
     67c:	a0 93 92 00 	sts	0x0092, r26
     680:	b0 93 93 00 	sts	0x0093, r27

	next_cwid = cur_timer + get_msg_delay(CWID_DELAY);
     684:	8a e0       	ldi	r24, 0x0A	; 10
     686:	65 dd       	rcall	.-1334   	; 0x152 <get_msg_delay>
     688:	9b 01       	movw	r18, r22
     68a:	ac 01       	movw	r20, r24
     68c:	80 91 60 00 	lds	r24, 0x0060
     690:	90 91 61 00 	lds	r25, 0x0061
     694:	a0 91 62 00 	lds	r26, 0x0062
     698:	b0 91 63 00 	lds	r27, 0x0063
     69c:	82 0f       	add	r24, r18
     69e:	93 1f       	adc	r25, r19
     6a0:	a4 1f       	adc	r26, r20
     6a2:	b5 1f       	adc	r27, r21
     6a4:	80 93 af 00 	sts	0x00AF, r24
     6a8:	90 93 b0 00 	sts	0x00B0, r25
     6ac:	a0 93 b1 00 	sts	0x00B1, r26
     6b0:	b0 93 b2 00 	sts	0x00B2, r27

	init_tx();
     6b4:	68 dd       	rcall	.-1328   	; 0x186 <init_tx>

	sei();
     6b6:	78 94       	sei

	while(1)
	{
		// Latch the current time
		// MUST disable interrupts during this read or there will be an occasional corruption of cur_timer
		cli();
     6b8:	f8 94       	cli
		cur_timer = timer;
     6ba:	80 91 94 00 	lds	r24, 0x0094
     6be:	90 91 95 00 	lds	r25, 0x0095
     6c2:	a0 91 96 00 	lds	r26, 0x0096
     6c6:	b0 91 97 00 	lds	r27, 0x0097
     6ca:	80 93 60 00 	sts	0x0060, r24
     6ce:	90 93 61 00 	sts	0x0061, r25
     6d2:	a0 93 62 00 	sts	0x0062, r26
     6d6:	b0 93 63 00 	sts	0x0063, r27
		sei();
     6da:	78 94       	sei

		// Handle CW ID if one hasn't been triggered in 10 minutes
		if(cur_timer > next_cwid && !cwid && cur_mode != MODE_CW)
     6dc:	20 91 60 00 	lds	r18, 0x0060
     6e0:	30 91 61 00 	lds	r19, 0x0061
     6e4:	40 91 62 00 	lds	r20, 0x0062
     6e8:	50 91 63 00 	lds	r21, 0x0063
     6ec:	80 91 af 00 	lds	r24, 0x00AF
     6f0:	90 91 b0 00 	lds	r25, 0x00B0
     6f4:	a0 91 b1 00 	lds	r26, 0x00B1
     6f8:	b0 91 b2 00 	lds	r27, 0x00B2
     6fc:	82 17       	cp	r24, r18
     6fe:	93 07       	cpc	r25, r19
     700:	a4 07       	cpc	r26, r20
     702:	b5 07       	cpc	r27, r21
     704:	08 f5       	brcc	.+66     	; 0x748 <main+0x292>
     706:	80 91 66 00 	lds	r24, 0x0066
     70a:	88 23       	and	r24, r24
     70c:	e9 f4       	brne	.+58     	; 0x748 <main+0x292>
     70e:	80 91 9d 00 	lds	r24, 0x009D
     712:	82 30       	cpi	r24, 0x02	; 2
     714:	c9 f0       	breq	.+50     	; 0x748 <main+0x292>
		{
			init_cwid();
     716:	2a de       	rcall	.-940    	; 0x36c <init_cwid>
			next_cwid = cur_timer + get_msg_delay(CWID_DELAY);
     718:	8a e0       	ldi	r24, 0x0A	; 10
     71a:	1b dd       	rcall	.-1482   	; 0x152 <get_msg_delay>
     71c:	9b 01       	movw	r18, r22
     71e:	ac 01       	movw	r20, r24
     720:	80 91 60 00 	lds	r24, 0x0060
     724:	90 91 61 00 	lds	r25, 0x0061
     728:	a0 91 62 00 	lds	r26, 0x0062
     72c:	b0 91 63 00 	lds	r27, 0x0063
     730:	82 0f       	add	r24, r18
     732:	93 1f       	adc	r25, r19
     734:	a4 1f       	adc	r26, r20
     736:	b5 1f       	adc	r27, r21
     738:	80 93 af 00 	sts	0x00AF, r24
     73c:	90 93 b0 00 	sts	0x00B0, r25
     740:	a0 93 b1 00 	sts	0x00B1, r26
     744:	b0 93 b2 00 	sts	0x00B2, r27
		}

		// State machine
		switch(cur_mode)
     748:	80 91 9d 00 	lds	r24, 0x009D
     74c:	88 2f       	mov	r24, r24
     74e:	90 e0       	ldi	r25, 0x00	; 0
     750:	99 23       	and	r25, r25
     752:	0c f4       	brge	.+2      	; 0x756 <main+0x2a0>
     754:	3f c4       	rjmp	.+2174   	; 0xfd4 <main+0xb1e>
     756:	83 30       	cpi	r24, 0x03	; 3
     758:	91 05       	cpc	r25, r1
     75a:	2c f0       	brlt	.+10     	; 0x766 <main+0x2b0>
     75c:	83 30       	cpi	r24, 0x03	; 3
     75e:	91 05       	cpc	r25, r1
     760:	09 f4       	brne	.+2      	; 0x764 <main+0x2ae>
     762:	e4 c3       	rjmp	.+1992   	; 0xf2c <main+0xa76>
     764:	37 c4       	rjmp	.+2158   	; 0xfd4 <main+0xb1e>
		{
		case MODE_DFCW6:
		case MODE_QRSS6:
		case MODE_CW:
			switch(cur_state)
     766:	80 91 a3 00 	lds	r24, 0x00A3
     76a:	88 2f       	mov	r24, r24
     76c:	90 e0       	ldi	r25, 0x00	; 0
     76e:	83 30       	cpi	r24, 0x03	; 3
     770:	91 05       	cpc	r25, r1
     772:	3c f4       	brge	.+14     	; 0x782 <main+0x2cc>
     774:	81 30       	cpi	r24, 0x01	; 1
     776:	91 05       	cpc	r25, r1
     778:	0c f0       	brlt	.+2      	; 0x77c <main+0x2c6>
     77a:	23 c3       	rjmp	.+1606   	; 0xdc2 <main+0x90c>
     77c:	00 97       	sbiw	r24, 0x00	; 0
     77e:	51 f0       	breq	.+20     	; 0x794 <main+0x2de>
     780:	cc c3       	rjmp	.+1944   	; 0xf1a <main+0xa64>
     782:	87 30       	cpi	r24, 0x07	; 7
     784:	91 05       	cpc	r25, r1
     786:	0c f4       	brge	.+2      	; 0x78a <main+0x2d4>
     788:	98 c3       	rjmp	.+1840   	; 0xeba <main+0xa04>
     78a:	89 30       	cpi	r24, 0x09	; 9
     78c:	91 05       	cpc	r25, r1
     78e:	09 f4       	brne	.+2      	; 0x792 <main+0x2dc>
     790:	eb c2       	rjmp	.+1494   	; 0xd68 <main+0x8b2>
     792:	c3 c3       	rjmp	.+1926   	; 0xf1a <main+0xa64>
			{
			case STATE_IDLE:
				// TX off
				KEY_PORT &= ~(_BV(KEY));
     794:	88 e3       	ldi	r24, 0x38	; 56
     796:	90 e0       	ldi	r25, 0x00	; 0
     798:	28 e3       	ldi	r18, 0x38	; 56
     79a:	30 e0       	ldi	r19, 0x00	; 0
     79c:	f9 01       	movw	r30, r18
     79e:	20 81       	ld	r18, Z
     7a0:	27 7f       	andi	r18, 0xF7	; 247
     7a2:	fc 01       	movw	r30, r24
     7a4:	20 83       	st	Z, r18

				if(msg_delay > 0 && msg_delay_end <= cur_timer && cur_msg_p == msg_buffer)
     7a6:	80 91 a6 00 	lds	r24, 0x00A6
     7aa:	88 23       	and	r24, r24
     7ac:	09 f4       	brne	.+2      	; 0x7b0 <main+0x2fa>
     7ae:	6e c0       	rjmp	.+220    	; 0x88c <main+0x3d6>
     7b0:	20 91 90 00 	lds	r18, 0x0090
     7b4:	30 91 91 00 	lds	r19, 0x0091
     7b8:	40 91 92 00 	lds	r20, 0x0092
     7bc:	50 91 93 00 	lds	r21, 0x0093
     7c0:	80 91 60 00 	lds	r24, 0x0060
     7c4:	90 91 61 00 	lds	r25, 0x0061
     7c8:	a0 91 62 00 	lds	r26, 0x0062
     7cc:	b0 91 63 00 	lds	r27, 0x0063
     7d0:	82 17       	cp	r24, r18
     7d2:	93 07       	cpc	r25, r19
     7d4:	a4 07       	cpc	r26, r20
     7d6:	b5 07       	cpc	r27, r21
     7d8:	08 f4       	brcc	.+2      	; 0x7dc <main+0x326>
     7da:	58 c0       	rjmp	.+176    	; 0x88c <main+0x3d6>
     7dc:	80 91 b5 00 	lds	r24, 0x00B5
     7e0:	90 91 b6 00 	lds	r25, 0x00B6
     7e4:	f0 e0       	ldi	r31, 0x00	; 0
     7e6:	87 36       	cpi	r24, 0x67	; 103
     7e8:	9f 07       	cpc	r25, r31
     7ea:	09 f0       	breq	.+2      	; 0x7ee <main+0x338>
     7ec:	4f c0       	rjmp	.+158    	; 0x88c <main+0x3d6>
				{
					msg_delay_end = cur_timer + get_msg_delay(msg_delay);
     7ee:	80 91 a6 00 	lds	r24, 0x00A6
     7f2:	af dc       	rcall	.-1698   	; 0x152 <get_msg_delay>
     7f4:	9b 01       	movw	r18, r22
     7f6:	ac 01       	movw	r20, r24
     7f8:	80 91 60 00 	lds	r24, 0x0060
     7fc:	90 91 61 00 	lds	r25, 0x0061
     800:	a0 91 62 00 	lds	r26, 0x0062
     804:	b0 91 63 00 	lds	r27, 0x0063
     808:	82 0f       	add	r24, r18
     80a:	93 1f       	adc	r25, r19
     80c:	a4 1f       	adc	r26, r20
     80e:	b5 1f       	adc	r27, r21
     810:	80 93 90 00 	sts	0x0090, r24
     814:	90 93 91 00 	sts	0x0091, r25
     818:	a0 93 92 00 	sts	0x0092, r26
     81c:	b0 93 93 00 	sts	0x0093, r27
					cur_state_end = cur_timer + (dit_length * MULT_WORDDELAY);
     820:	20 91 99 00 	lds	r18, 0x0099
     824:	30 91 9a 00 	lds	r19, 0x009A
     828:	40 91 9b 00 	lds	r20, 0x009B
     82c:	50 91 9c 00 	lds	r21, 0x009C
     830:	da 01       	movw	r26, r20
     832:	c9 01       	movw	r24, r18
     834:	88 0f       	add	r24, r24
     836:	99 1f       	adc	r25, r25
     838:	aa 1f       	adc	r26, r26
     83a:	bb 1f       	adc	r27, r27
     83c:	88 0f       	add	r24, r24
     83e:	99 1f       	adc	r25, r25
     840:	aa 1f       	adc	r26, r26
     842:	bb 1f       	adc	r27, r27
     844:	88 0f       	add	r24, r24
     846:	99 1f       	adc	r25, r25
     848:	aa 1f       	adc	r26, r26
     84a:	bb 1f       	adc	r27, r27
     84c:	7c 01       	movw	r14, r24
     84e:	8d 01       	movw	r16, r26
     850:	e2 1a       	sub	r14, r18
     852:	f3 0a       	sbc	r15, r19
     854:	04 0b       	sbc	r16, r20
     856:	15 0b       	sbc	r17, r21
     858:	a8 01       	movw	r20, r16
     85a:	97 01       	movw	r18, r14
     85c:	80 91 60 00 	lds	r24, 0x0060
     860:	90 91 61 00 	lds	r25, 0x0061
     864:	a0 91 62 00 	lds	r26, 0x0062
     868:	b0 91 63 00 	lds	r27, 0x0063
     86c:	82 0f       	add	r24, r18
     86e:	93 1f       	adc	r25, r19
     870:	a4 1f       	adc	r26, r20
     872:	b5 1f       	adc	r27, r21
     874:	80 93 a7 00 	sts	0x00A7, r24
     878:	90 93 a8 00 	sts	0x00A8, r25
     87c:	a0 93 a9 00 	sts	0x00A9, r26
     880:	b0 93 aa 00 	sts	0x00AA, r27
					//if(cur_mode != MODE_CW)
						cur_state = STATE_PREAMBLE;
     884:	89 e0       	ldi	r24, 0x09	; 9
     886:	80 93 a3 00 	sts	0x00A3, r24
					//else
						//cur_state = STATE_IDLE;
					break;
     88a:	4f c3       	rjmp	.+1694   	; 0xf2a <main+0xa74>
				}

				// If this is the first time thru the message loop, get the first character, then wait a moment before starting message if not CW
				if((cur_msg_p == msg_buffer) && (cur_character == '\0'))
     88c:	80 91 b5 00 	lds	r24, 0x00B5
     890:	90 91 b6 00 	lds	r25, 0x00B6
     894:	00 e0       	ldi	r16, 0x00	; 0
     896:	87 36       	cpi	r24, 0x67	; 103
     898:	90 07       	cpc	r25, r16
     89a:	09 f0       	breq	.+2      	; 0x89e <main+0x3e8>
     89c:	48 c0       	rjmp	.+144    	; 0x92e <main+0x478>
     89e:	80 91 64 00 	lds	r24, 0x0064
     8a2:	88 23       	and	r24, r24
     8a4:	09 f0       	breq	.+2      	; 0x8a8 <main+0x3f2>
     8a6:	43 c0       	rjmp	.+134    	; 0x92e <main+0x478>
				{
					cur_character = pgm_read_byte(&morsechar[(*cur_msg_p) - MORSE_CHAR_START]);
     8a8:	80 91 b5 00 	lds	r24, 0x00B5
     8ac:	90 91 b6 00 	lds	r25, 0x00B6
     8b0:	fc 01       	movw	r30, r24
     8b2:	80 81       	ld	r24, Z
     8b4:	88 2f       	mov	r24, r24
     8b6:	90 e0       	ldi	r25, 0x00	; 0
     8b8:	80 97       	sbiw	r24, 0x20	; 32
     8ba:	82 5e       	subi	r24, 0xE2	; 226
     8bc:	9f 4f       	sbci	r25, 0xFF	; 255
     8be:	9e 83       	std	Y+6, r25	; 0x06
     8c0:	8d 83       	std	Y+5, r24	; 0x05
     8c2:	8d 81       	ldd	r24, Y+5	; 0x05
     8c4:	9e 81       	ldd	r25, Y+6	; 0x06
     8c6:	fc 01       	movw	r30, r24
     8c8:	14 91       	lpm	r17, Z+
     8ca:	1f 83       	std	Y+7, r17	; 0x07
     8cc:	8f 81       	ldd	r24, Y+7	; 0x07
     8ce:	80 93 64 00 	sts	0x0064, r24
					if(cur_mode != MODE_CW)
     8d2:	80 91 9d 00 	lds	r24, 0x009D
     8d6:	82 30       	cpi	r24, 0x02	; 2
     8d8:	51 f1       	breq	.+84     	; 0x92e <main+0x478>
					{
						cur_state_end = cur_timer + (dit_length * MULT_DAH);
     8da:	20 91 99 00 	lds	r18, 0x0099
     8de:	30 91 9a 00 	lds	r19, 0x009A
     8e2:	40 91 9b 00 	lds	r20, 0x009B
     8e6:	50 91 9c 00 	lds	r21, 0x009C
     8ea:	da 01       	movw	r26, r20
     8ec:	c9 01       	movw	r24, r18
     8ee:	88 0f       	add	r24, r24
     8f0:	99 1f       	adc	r25, r25
     8f2:	aa 1f       	adc	r26, r26
     8f4:	bb 1f       	adc	r27, r27
     8f6:	28 0f       	add	r18, r24
     8f8:	39 1f       	adc	r19, r25
     8fa:	4a 1f       	adc	r20, r26
     8fc:	5b 1f       	adc	r21, r27
     8fe:	80 91 60 00 	lds	r24, 0x0060
     902:	90 91 61 00 	lds	r25, 0x0061
     906:	a0 91 62 00 	lds	r26, 0x0062
     90a:	b0 91 63 00 	lds	r27, 0x0063
     90e:	82 0f       	add	r24, r18
     910:	93 1f       	adc	r25, r19
     912:	a4 1f       	adc	r26, r20
     914:	b5 1f       	adc	r27, r21
     916:	80 93 a7 00 	sts	0x00A7, r24
     91a:	90 93 a8 00 	sts	0x00A8, r25
     91e:	a0 93 a9 00 	sts	0x00A9, r26
     922:	b0 93 aa 00 	sts	0x00AA, r27
						cur_state = STATE_PREAMBLE;
     926:	89 e0       	ldi	r24, 0x09	; 9
     928:	80 93 a3 00 	sts	0x00A3, r24
						break;
     92c:	fe c2       	rjmp	.+1532   	; 0xf2a <main+0xa74>
					}
				}

				// Get the current element in the current character
				if(cur_character != '\0')
     92e:	80 91 64 00 	lds	r24, 0x0064
     932:	88 23       	and	r24, r24
     934:	09 f4       	brne	.+2      	; 0x938 <main+0x482>
     936:	ea c0       	rjmp	.+468    	; 0xb0c <main+0x656>
				{
					if(cur_character == 0b10000000 || cur_character == 0b11111111)	// End of character marker or SPACE
     938:	80 91 64 00 	lds	r24, 0x0064
     93c:	80 38       	cpi	r24, 0x80	; 128
     93e:	29 f0       	breq	.+10     	; 0x94a <main+0x494>
     940:	80 91 64 00 	lds	r24, 0x0064
     944:	8f 3f       	cpi	r24, 0xFF	; 255
     946:	09 f0       	breq	.+2      	; 0x94a <main+0x494>
     948:	8d c0       	rjmp	.+282    	; 0xa64 <main+0x5ae>
					{
						// Set next state based on whether EOC or SPACE
						if(cur_character == 0b10000000)
     94a:	80 91 64 00 	lds	r24, 0x0064
     94e:	80 38       	cpi	r24, 0x80	; 128
     950:	51 f5       	brne	.+84     	; 0x9a6 <main+0x4f0>
						{
							cur_state_end = cur_timer + (dit_length * MULT_DAH);
     952:	20 91 99 00 	lds	r18, 0x0099
     956:	30 91 9a 00 	lds	r19, 0x009A
     95a:	40 91 9b 00 	lds	r20, 0x009B
     95e:	50 91 9c 00 	lds	r21, 0x009C
     962:	da 01       	movw	r26, r20
     964:	c9 01       	movw	r24, r18
     966:	88 0f       	add	r24, r24
     968:	99 1f       	adc	r25, r25
     96a:	aa 1f       	adc	r26, r26
     96c:	bb 1f       	adc	r27, r27
     96e:	28 0f       	add	r18, r24
     970:	39 1f       	adc	r19, r25
     972:	4a 1f       	adc	r20, r26
     974:	5b 1f       	adc	r21, r27
     976:	80 91 60 00 	lds	r24, 0x0060
     97a:	90 91 61 00 	lds	r25, 0x0061
     97e:	a0 91 62 00 	lds	r26, 0x0062
     982:	b0 91 63 00 	lds	r27, 0x0063
     986:	82 0f       	add	r24, r18
     988:	93 1f       	adc	r25, r19
     98a:	a4 1f       	adc	r26, r20
     98c:	b5 1f       	adc	r27, r21
     98e:	80 93 a7 00 	sts	0x00A7, r24
     992:	90 93 a8 00 	sts	0x00A8, r25
     996:	a0 93 a9 00 	sts	0x00A9, r26
     99a:	b0 93 aa 00 	sts	0x00AA, r27
							cur_state = STATE_DAHDELAY;
     99e:	84 e0       	ldi	r24, 0x04	; 4
     9a0:	80 93 a3 00 	sts	0x00A3, r24
     9a4:	35 c0       	rjmp	.+106    	; 0xa10 <main+0x55a>
						}
						else
						{
							cur_state_end = cur_timer + (dit_length * MULT_WORDDELAY);
     9a6:	20 91 99 00 	lds	r18, 0x0099
     9aa:	30 91 9a 00 	lds	r19, 0x009A
     9ae:	40 91 9b 00 	lds	r20, 0x009B
     9b2:	50 91 9c 00 	lds	r21, 0x009C
     9b6:	da 01       	movw	r26, r20
     9b8:	c9 01       	movw	r24, r18
     9ba:	88 0f       	add	r24, r24
     9bc:	99 1f       	adc	r25, r25
     9be:	aa 1f       	adc	r26, r26
     9c0:	bb 1f       	adc	r27, r27
     9c2:	88 0f       	add	r24, r24
     9c4:	99 1f       	adc	r25, r25
     9c6:	aa 1f       	adc	r26, r26
     9c8:	bb 1f       	adc	r27, r27
     9ca:	88 0f       	add	r24, r24
     9cc:	99 1f       	adc	r25, r25
     9ce:	aa 1f       	adc	r26, r26
     9d0:	bb 1f       	adc	r27, r27
     9d2:	7c 01       	movw	r14, r24
     9d4:	8d 01       	movw	r16, r26
     9d6:	e2 1a       	sub	r14, r18
     9d8:	f3 0a       	sbc	r15, r19
     9da:	04 0b       	sbc	r16, r20
     9dc:	15 0b       	sbc	r17, r21
     9de:	a8 01       	movw	r20, r16
     9e0:	97 01       	movw	r18, r14
     9e2:	80 91 60 00 	lds	r24, 0x0060
     9e6:	90 91 61 00 	lds	r25, 0x0061
     9ea:	a0 91 62 00 	lds	r26, 0x0062
     9ee:	b0 91 63 00 	lds	r27, 0x0063
     9f2:	82 0f       	add	r24, r18
     9f4:	93 1f       	adc	r25, r19
     9f6:	a4 1f       	adc	r26, r20
     9f8:	b5 1f       	adc	r27, r21
     9fa:	80 93 a7 00 	sts	0x00A7, r24
     9fe:	90 93 a8 00 	sts	0x00A8, r25
     a02:	a0 93 a9 00 	sts	0x00A9, r26
     a06:	b0 93 aa 00 	sts	0x00AA, r27
							cur_state = STATE_WORDDELAY;
     a0a:	85 e0       	ldi	r24, 0x05	; 5
     a0c:	80 93 a3 00 	sts	0x00A3, r24
						}

						// Grab next character, set state to inter-character delay
						cur_msg_p++;
     a10:	80 91 b5 00 	lds	r24, 0x00B5
     a14:	90 91 b6 00 	lds	r25, 0x00B6
     a18:	01 96       	adiw	r24, 0x01	; 1
     a1a:	90 93 b6 00 	sts	0x00B6, r25
     a1e:	80 93 b5 00 	sts	0x00B5, r24

						// If we read a NULL from the announce buffer, set cur_character to NULL,
						// otherwise set to correct morse character
						if((*cur_msg_p) == '\0')
     a22:	80 91 b5 00 	lds	r24, 0x00B5
     a26:	90 91 b6 00 	lds	r25, 0x00B6
     a2a:	fc 01       	movw	r30, r24
     a2c:	80 81       	ld	r24, Z
     a2e:	88 23       	and	r24, r24
     a30:	19 f4       	brne	.+6      	; 0xa38 <main+0x582>
							cur_character = '\0';
     a32:	10 92 64 00 	sts	0x0064, r1
						// Grab next character, set state to inter-character delay
						cur_msg_p++;

						// If we read a NULL from the announce buffer, set cur_character to NULL,
						// otherwise set to correct morse character
						if((*cur_msg_p) == '\0')
     a36:	69 c0       	rjmp	.+210    	; 0xb0a <main+0x654>
							cur_character = '\0';
						else
							cur_character = pgm_read_byte(&morsechar[(*cur_msg_p) - MORSE_CHAR_START]);
     a38:	80 91 b5 00 	lds	r24, 0x00B5
     a3c:	90 91 b6 00 	lds	r25, 0x00B6
     a40:	fc 01       	movw	r30, r24
     a42:	80 81       	ld	r24, Z
     a44:	88 2f       	mov	r24, r24
     a46:	90 e0       	ldi	r25, 0x00	; 0
     a48:	80 97       	sbiw	r24, 0x20	; 32
     a4a:	82 5e       	subi	r24, 0xE2	; 226
     a4c:	9f 4f       	sbci	r25, 0xFF	; 255
     a4e:	99 87       	std	Y+9, r25	; 0x09
     a50:	88 87       	std	Y+8, r24	; 0x08
     a52:	88 85       	ldd	r24, Y+8	; 0x08
     a54:	99 85       	ldd	r25, Y+9	; 0x09
     a56:	fc 01       	movw	r30, r24
     a58:	14 91       	lpm	r17, Z+
     a5a:	1a 87       	std	Y+10, r17	; 0x0a
     a5c:	8a 85       	ldd	r24, Y+10	; 0x0a
     a5e:	80 93 64 00 	sts	0x0064, r24
						// Grab next character, set state to inter-character delay
						cur_msg_p++;

						// If we read a NULL from the announce buffer, set cur_character to NULL,
						// otherwise set to correct morse character
						if((*cur_msg_p) == '\0')
     a62:	53 c0       	rjmp	.+166    	; 0xb0a <main+0x654>
							cur_character = pgm_read_byte(&morsechar[(*cur_msg_p) - MORSE_CHAR_START]);
					}
					else
					{
						// Mask off MSb, set cur_element
						if((cur_character & 0b10000000) == 0b10000000)
     a64:	80 91 64 00 	lds	r24, 0x0064
     a68:	88 23       	and	r24, r24
     a6a:	54 f5       	brge	.+84     	; 0xac0 <main+0x60a>
						{
							cur_state_end = cur_timer + (dit_length * MULT_DAH);
     a6c:	20 91 99 00 	lds	r18, 0x0099
     a70:	30 91 9a 00 	lds	r19, 0x009A
     a74:	40 91 9b 00 	lds	r20, 0x009B
     a78:	50 91 9c 00 	lds	r21, 0x009C
     a7c:	da 01       	movw	r26, r20
     a7e:	c9 01       	movw	r24, r18
     a80:	88 0f       	add	r24, r24
     a82:	99 1f       	adc	r25, r25
     a84:	aa 1f       	adc	r26, r26
     a86:	bb 1f       	adc	r27, r27
     a88:	28 0f       	add	r18, r24
     a8a:	39 1f       	adc	r19, r25
     a8c:	4a 1f       	adc	r20, r26
     a8e:	5b 1f       	adc	r21, r27
     a90:	80 91 60 00 	lds	r24, 0x0060
     a94:	90 91 61 00 	lds	r25, 0x0061
     a98:	a0 91 62 00 	lds	r26, 0x0062
     a9c:	b0 91 63 00 	lds	r27, 0x0063
     aa0:	82 0f       	add	r24, r18
     aa2:	93 1f       	adc	r25, r19
     aa4:	a4 1f       	adc	r26, r20
     aa6:	b5 1f       	adc	r27, r21
     aa8:	80 93 a7 00 	sts	0x00A7, r24
     aac:	90 93 a8 00 	sts	0x00A8, r25
     ab0:	a0 93 a9 00 	sts	0x00A9, r26
     ab4:	b0 93 aa 00 	sts	0x00AA, r27
							cur_state = STATE_DAH;
     ab8:	82 e0       	ldi	r24, 0x02	; 2
     aba:	80 93 a3 00 	sts	0x00A3, r24
     abe:	1f c0       	rjmp	.+62     	; 0xafe <main+0x648>
						}
						else
						{
							cur_state_end = cur_timer + dit_length;
     ac0:	20 91 60 00 	lds	r18, 0x0060
     ac4:	30 91 61 00 	lds	r19, 0x0061
     ac8:	40 91 62 00 	lds	r20, 0x0062
     acc:	50 91 63 00 	lds	r21, 0x0063
     ad0:	80 91 99 00 	lds	r24, 0x0099
     ad4:	90 91 9a 00 	lds	r25, 0x009A
     ad8:	a0 91 9b 00 	lds	r26, 0x009B
     adc:	b0 91 9c 00 	lds	r27, 0x009C
     ae0:	82 0f       	add	r24, r18
     ae2:	93 1f       	adc	r25, r19
     ae4:	a4 1f       	adc	r26, r20
     ae6:	b5 1f       	adc	r27, r21
     ae8:	80 93 a7 00 	sts	0x00A7, r24
     aec:	90 93 a8 00 	sts	0x00A8, r25
     af0:	a0 93 a9 00 	sts	0x00A9, r26
     af4:	b0 93 aa 00 	sts	0x00AA, r27
							cur_state = STATE_DIT;
     af8:	81 e0       	ldi	r24, 0x01	; 1
     afa:	80 93 a3 00 	sts	0x00A3, r24
						}

						// Shift left to get next element
						cur_character = cur_character << 1;
     afe:	80 91 64 00 	lds	r24, 0x0064
     b02:	88 0f       	add	r24, r24
     b04:	80 93 64 00 	sts	0x0064, r24
						}

					}
				}

				break;
     b08:	09 c2       	rjmp	.+1042   	; 0xf1c <main+0xa66>
     b0a:	08 c2       	rjmp	.+1040   	; 0xf1c <main+0xa66>
					}
				}
				else // Buffer is now empty
				{
					// If in CW ID mode, reset back to original parameters
					if(cwid)
     b0c:	80 91 66 00 	lds	r24, 0x0066
     b10:	88 23       	and	r24, r24
     b12:	09 f4       	brne	.+2      	; 0xb16 <main+0x660>
     b14:	52 c0       	rjmp	.+164    	; 0xbba <main+0x704>
					{
						cur_mode = prev_mode;
     b16:	80 91 a2 00 	lds	r24, 0x00A2
     b1a:	80 93 9d 00 	sts	0x009D, r24
						wpm = prev_wpm;
     b1e:	80 91 b3 00 	lds	r24, 0x00B3
     b22:	90 91 b4 00 	lds	r25, 0x00B4
     b26:	90 93 ac 00 	sts	0x00AC, r25
     b2a:	80 93 ab 00 	sts	0x00AB, r24
						set_wpm(wpm);
     b2e:	80 91 ab 00 	lds	r24, 0x00AB
     b32:	90 91 ac 00 	lds	r25, 0x00AC
     b36:	cc 01       	movw	r24, r24
     b38:	a0 e0       	ldi	r26, 0x00	; 0
     b3a:	b0 e0       	ldi	r27, 0x00	; 0
     b3c:	bc 01       	movw	r22, r24
     b3e:	cd 01       	movw	r24, r26
     b40:	e2 da       	rcall	.-2620   	; 0x106 <set_wpm>
						cur_character = prev_character;
     b42:	80 91 65 00 	lds	r24, 0x0065
     b46:	80 93 64 00 	sts	0x0064, r24
						reset_buffer();
     b4a:	f3 db       	rcall	.-2074   	; 0x332 <reset_buffer>
						cur_msg_p = prev_msg_p;
     b4c:	80 91 ad 00 	lds	r24, 0x00AD
     b50:	90 91 ae 00 	lds	r25, 0x00AE
     b54:	90 93 b6 00 	sts	0x00B6, r25
     b58:	80 93 b5 00 	sts	0x00B5, r24
						next_cwid = cur_timer + get_msg_delay(CWID_DELAY);
     b5c:	8a e0       	ldi	r24, 0x0A	; 10
     b5e:	f9 da       	rcall	.-2574   	; 0x152 <get_msg_delay>
     b60:	9b 01       	movw	r18, r22
     b62:	ac 01       	movw	r20, r24
     b64:	80 91 60 00 	lds	r24, 0x0060
     b68:	90 91 61 00 	lds	r25, 0x0061
     b6c:	a0 91 62 00 	lds	r26, 0x0062
     b70:	b0 91 63 00 	lds	r27, 0x0063
     b74:	82 0f       	add	r24, r18
     b76:	93 1f       	adc	r25, r19
     b78:	a4 1f       	adc	r26, r20
     b7a:	b5 1f       	adc	r27, r21
     b7c:	80 93 af 00 	sts	0x00AF, r24
     b80:	90 93 b0 00 	sts	0x00B0, r25
     b84:	a0 93 b1 00 	sts	0x00B1, r26
     b88:	b0 93 b2 00 	sts	0x00B2, r27
						cwid = FALSE;
     b8c:	10 92 66 00 	sts	0x0066, r1

						cur_state_end = prev_state_end;
     b90:	80 91 9e 00 	lds	r24, 0x009E
     b94:	90 91 9f 00 	lds	r25, 0x009F
     b98:	a0 91 a0 00 	lds	r26, 0x00A0
     b9c:	b0 91 a1 00 	lds	r27, 0x00A1
     ba0:	80 93 a7 00 	sts	0x00A7, r24
     ba4:	90 93 a8 00 	sts	0x00A8, r25
     ba8:	a0 93 a9 00 	sts	0x00A9, r26
     bac:	b0 93 aa 00 	sts	0x00AA, r27
						cur_state = prev_state;
     bb0:	80 91 98 00 	lds	r24, 0x0098
     bb4:	80 93 a3 00 	sts	0x00A3, r24
						}

					}
				}

				break;
     bb8:	b1 c1       	rjmp	.+866    	; 0xf1c <main+0xa66>
						cur_state = prev_state;
					}
					else
					{
						// Reload the message buffer and set buffer pointer back to beginning
						reset_buffer();
     bba:	bb db       	rcall	.-2186   	; 0x332 <reset_buffer>

						if(msg_delay == 0)
     bbc:	80 91 a6 00 	lds	r24, 0x00A6
     bc0:	88 23       	and	r24, r24
     bc2:	b1 f5       	brne	.+108    	; 0xc30 <main+0x77a>
						{
							// If a constantly repeating message, put a word delay at the end of message
							cur_state_end = cur_timer + (dit_length * MULT_WORDDELAY);
     bc4:	20 91 99 00 	lds	r18, 0x0099
     bc8:	30 91 9a 00 	lds	r19, 0x009A
     bcc:	40 91 9b 00 	lds	r20, 0x009B
     bd0:	50 91 9c 00 	lds	r21, 0x009C
     bd4:	da 01       	movw	r26, r20
     bd6:	c9 01       	movw	r24, r18
     bd8:	88 0f       	add	r24, r24
     bda:	99 1f       	adc	r25, r25
     bdc:	aa 1f       	adc	r26, r26
     bde:	bb 1f       	adc	r27, r27
     be0:	88 0f       	add	r24, r24
     be2:	99 1f       	adc	r25, r25
     be4:	aa 1f       	adc	r26, r26
     be6:	bb 1f       	adc	r27, r27
     be8:	88 0f       	add	r24, r24
     bea:	99 1f       	adc	r25, r25
     bec:	aa 1f       	adc	r26, r26
     bee:	bb 1f       	adc	r27, r27
     bf0:	7c 01       	movw	r14, r24
     bf2:	8d 01       	movw	r16, r26
     bf4:	e2 1a       	sub	r14, r18
     bf6:	f3 0a       	sbc	r15, r19
     bf8:	04 0b       	sbc	r16, r20
     bfa:	15 0b       	sbc	r17, r21
     bfc:	a8 01       	movw	r20, r16
     bfe:	97 01       	movw	r18, r14
     c00:	80 91 60 00 	lds	r24, 0x0060
     c04:	90 91 61 00 	lds	r25, 0x0061
     c08:	a0 91 62 00 	lds	r26, 0x0062
     c0c:	b0 91 63 00 	lds	r27, 0x0063
     c10:	82 0f       	add	r24, r18
     c12:	93 1f       	adc	r25, r19
     c14:	a4 1f       	adc	r26, r20
     c16:	b5 1f       	adc	r27, r21
     c18:	80 93 a7 00 	sts	0x00A7, r24
     c1c:	90 93 a8 00 	sts	0x00A8, r25
     c20:	a0 93 a9 00 	sts	0x00A9, r26
     c24:	b0 93 aa 00 	sts	0x00AA, r27
							cur_state = STATE_WORDDELAY;
     c28:	85 e0       	ldi	r24, 0x05	; 5
     c2a:	80 93 a3 00 	sts	0x00A3, r24
     c2e:	7d c0       	rjmp	.+250    	; 0xd2a <main+0x874>
						}
						else
						{
							// Otherwise, set the message delay time
							if(msg_delay_end < cur_timer + (dit_length * MULT_WORDDELAY))
     c30:	20 91 99 00 	lds	r18, 0x0099
     c34:	30 91 9a 00 	lds	r19, 0x009A
     c38:	40 91 9b 00 	lds	r20, 0x009B
     c3c:	50 91 9c 00 	lds	r21, 0x009C
     c40:	da 01       	movw	r26, r20
     c42:	c9 01       	movw	r24, r18
     c44:	88 0f       	add	r24, r24
     c46:	99 1f       	adc	r25, r25
     c48:	aa 1f       	adc	r26, r26
     c4a:	bb 1f       	adc	r27, r27
     c4c:	88 0f       	add	r24, r24
     c4e:	99 1f       	adc	r25, r25
     c50:	aa 1f       	adc	r26, r26
     c52:	bb 1f       	adc	r27, r27
     c54:	88 0f       	add	r24, r24
     c56:	99 1f       	adc	r25, r25
     c58:	aa 1f       	adc	r26, r26
     c5a:	bb 1f       	adc	r27, r27
     c5c:	7c 01       	movw	r14, r24
     c5e:	8d 01       	movw	r16, r26
     c60:	e2 1a       	sub	r14, r18
     c62:	f3 0a       	sbc	r15, r19
     c64:	04 0b       	sbc	r16, r20
     c66:	15 0b       	sbc	r17, r21
     c68:	a8 01       	movw	r20, r16
     c6a:	97 01       	movw	r18, r14
     c6c:	80 91 60 00 	lds	r24, 0x0060
     c70:	90 91 61 00 	lds	r25, 0x0061
     c74:	a0 91 62 00 	lds	r26, 0x0062
     c78:	b0 91 63 00 	lds	r27, 0x0063
     c7c:	28 0f       	add	r18, r24
     c7e:	39 1f       	adc	r19, r25
     c80:	4a 1f       	adc	r20, r26
     c82:	5b 1f       	adc	r21, r27
     c84:	80 91 90 00 	lds	r24, 0x0090
     c88:	90 91 91 00 	lds	r25, 0x0091
     c8c:	a0 91 92 00 	lds	r26, 0x0092
     c90:	b0 91 93 00 	lds	r27, 0x0093
     c94:	82 17       	cp	r24, r18
     c96:	93 07       	cpc	r25, r19
     c98:	a4 07       	cpc	r26, r20
     c9a:	b5 07       	cpc	r27, r21
     c9c:	98 f5       	brcc	.+102    	; 0xd04 <main+0x84e>
								cur_state_end = cur_timer + (dit_length * MULT_WORDDELAY);
     c9e:	20 91 99 00 	lds	r18, 0x0099
     ca2:	30 91 9a 00 	lds	r19, 0x009A
     ca6:	40 91 9b 00 	lds	r20, 0x009B
     caa:	50 91 9c 00 	lds	r21, 0x009C
     cae:	da 01       	movw	r26, r20
     cb0:	c9 01       	movw	r24, r18
     cb2:	88 0f       	add	r24, r24
     cb4:	99 1f       	adc	r25, r25
     cb6:	aa 1f       	adc	r26, r26
     cb8:	bb 1f       	adc	r27, r27
     cba:	88 0f       	add	r24, r24
     cbc:	99 1f       	adc	r25, r25
     cbe:	aa 1f       	adc	r26, r26
     cc0:	bb 1f       	adc	r27, r27
     cc2:	88 0f       	add	r24, r24
     cc4:	99 1f       	adc	r25, r25
     cc6:	aa 1f       	adc	r26, r26
     cc8:	bb 1f       	adc	r27, r27
     cca:	7c 01       	movw	r14, r24
     ccc:	8d 01       	movw	r16, r26
     cce:	e2 1a       	sub	r14, r18
     cd0:	f3 0a       	sbc	r15, r19
     cd2:	04 0b       	sbc	r16, r20
     cd4:	15 0b       	sbc	r17, r21
     cd6:	a8 01       	movw	r20, r16
     cd8:	97 01       	movw	r18, r14
     cda:	80 91 60 00 	lds	r24, 0x0060
     cde:	90 91 61 00 	lds	r25, 0x0061
     ce2:	a0 91 62 00 	lds	r26, 0x0062
     ce6:	b0 91 63 00 	lds	r27, 0x0063
     cea:	82 0f       	add	r24, r18
     cec:	93 1f       	adc	r25, r19
     cee:	a4 1f       	adc	r26, r20
     cf0:	b5 1f       	adc	r27, r21
     cf2:	80 93 a7 00 	sts	0x00A7, r24
     cf6:	90 93 a8 00 	sts	0x00A8, r25
     cfa:	a0 93 a9 00 	sts	0x00A9, r26
     cfe:	b0 93 aa 00 	sts	0x00AA, r27
     d02:	10 c0       	rjmp	.+32     	; 0xd24 <main+0x86e>
							else
								cur_state_end = msg_delay_end;
     d04:	80 91 90 00 	lds	r24, 0x0090
     d08:	90 91 91 00 	lds	r25, 0x0091
     d0c:	a0 91 92 00 	lds	r26, 0x0092
     d10:	b0 91 93 00 	lds	r27, 0x0093
     d14:	80 93 a7 00 	sts	0x00A7, r24
     d18:	90 93 a8 00 	sts	0x00A8, r25
     d1c:	a0 93 a9 00 	sts	0x00A9, r26
     d20:	b0 93 aa 00 	sts	0x00AA, r27

							cur_state = STATE_MSGDELAY;
     d24:	86 e0       	ldi	r24, 0x06	; 6
     d26:	80 93 a3 00 	sts	0x00A3, r24
						}


						// Do a CW ID
						if(cur_mode != MODE_CW)
     d2a:	80 91 9d 00 	lds	r24, 0x009D
     d2e:	82 30       	cpi	r24, 0x02	; 2
     d30:	09 f4       	brne	.+2      	; 0xd34 <main+0x87e>
     d32:	f4 c0       	rjmp	.+488    	; 0xf1c <main+0xa66>
						{
							init_cwid();
     d34:	1b db       	rcall	.-2506   	; 0x36c <init_cwid>
							next_cwid = cur_timer + get_msg_delay(CWID_DELAY);
     d36:	8a e0       	ldi	r24, 0x0A	; 10
     d38:	0c da       	rcall	.-3048   	; 0x152 <get_msg_delay>
     d3a:	9b 01       	movw	r18, r22
     d3c:	ac 01       	movw	r20, r24
     d3e:	80 91 60 00 	lds	r24, 0x0060
     d42:	90 91 61 00 	lds	r25, 0x0061
     d46:	a0 91 62 00 	lds	r26, 0x0062
     d4a:	b0 91 63 00 	lds	r27, 0x0063
     d4e:	82 0f       	add	r24, r18
     d50:	93 1f       	adc	r25, r19
     d52:	a4 1f       	adc	r26, r20
     d54:	b5 1f       	adc	r27, r21
     d56:	80 93 af 00 	sts	0x00AF, r24
     d5a:	90 93 b0 00 	sts	0x00B0, r25
     d5e:	a0 93 b1 00 	sts	0x00B1, r26
     d62:	b0 93 b2 00 	sts	0x00B2, r27
						}

					}
				}

				break;
     d66:	da c0       	rjmp	.+436    	; 0xf1c <main+0xa66>

			case STATE_PREAMBLE:
				// Wait a word delay with TX on before starting message
				FSK_PORT &= ~(_BV(FSK));
     d68:	88 e3       	ldi	r24, 0x38	; 56
     d6a:	90 e0       	ldi	r25, 0x00	; 0
     d6c:	28 e3       	ldi	r18, 0x38	; 56
     d6e:	30 e0       	ldi	r19, 0x00	; 0
     d70:	f9 01       	movw	r30, r18
     d72:	20 81       	ld	r18, Z
     d74:	2f 7e       	andi	r18, 0xEF	; 239
     d76:	fc 01       	movw	r30, r24
     d78:	20 83       	st	Z, r18

				if(cur_mode == MODE_QRSS6 ||cur_mode == MODE_CW)
     d7a:	80 91 9d 00 	lds	r24, 0x009D
     d7e:	81 30       	cpi	r24, 0x01	; 1
     d80:	21 f0       	breq	.+8      	; 0xd8a <main+0x8d4>
     d82:	80 91 9d 00 	lds	r24, 0x009D
     d86:	82 30       	cpi	r24, 0x02	; 2
     d88:	11 f4       	brne	.+4      	; 0xd8e <main+0x8d8>
				{
					// Transmitter off
					tx_off();
     d8a:	7c db       	rcall	.-2312   	; 0x484 <tx_off>
     d8c:	01 c0       	rjmp	.+2      	; 0xd90 <main+0x8da>
				}
				else
				{
					// Transmitter on
					tx_on();
     d8e:	61 db       	rcall	.-2366   	; 0x452 <tx_on>
				}


				// When done waiting, go back to IDLE state to start the message
				if(cur_timer > cur_state_end)
     d90:	20 91 60 00 	lds	r18, 0x0060
     d94:	30 91 61 00 	lds	r19, 0x0061
     d98:	40 91 62 00 	lds	r20, 0x0062
     d9c:	50 91 63 00 	lds	r21, 0x0063
     da0:	80 91 a7 00 	lds	r24, 0x00A7
     da4:	90 91 a8 00 	lds	r25, 0x00A8
     da8:	a0 91 a9 00 	lds	r26, 0x00A9
     dac:	b0 91 aa 00 	lds	r27, 0x00AA
     db0:	82 17       	cp	r24, r18
     db2:	93 07       	cpc	r25, r19
     db4:	a4 07       	cpc	r26, r20
     db6:	b5 07       	cpc	r27, r21
     db8:	08 f0       	brcs	.+2      	; 0xdbc <main+0x906>
     dba:	b2 c0       	rjmp	.+356    	; 0xf20 <main+0xa6a>
				{
					cur_state = STATE_IDLE;
     dbc:	10 92 a3 00 	sts	0x00A3, r1
				}
				break;
     dc0:	af c0       	rjmp	.+350    	; 0xf20 <main+0xa6a>

			case STATE_DIT:
			case STATE_DAH:
				switch(cur_mode)
     dc2:	80 91 9d 00 	lds	r24, 0x009D
     dc6:	88 2f       	mov	r24, r24
     dc8:	90 e0       	ldi	r25, 0x00	; 0
     dca:	00 97       	sbiw	r24, 0x00	; 0
     dcc:	31 f0       	breq	.+12     	; 0xdda <main+0x924>
     dce:	99 23       	and	r25, r25
     dd0:	d4 f0       	brlt	.+52     	; 0xe06 <main+0x950>
     dd2:	83 30       	cpi	r24, 0x03	; 3
     dd4:	91 05       	cpc	r25, r1
     dd6:	bc f4       	brge	.+46     	; 0xe06 <main+0x950>
     dd8:	0b c0       	rjmp	.+22     	; 0xdf0 <main+0x93a>
				{
				case MODE_DFCW6:
					// Transmitter on
					tx_on();
     dda:	3b db       	rcall	.-2442   	; 0x452 <tx_on>

					// Set FSK to MARK (lower capacitance/higher freq)
					FSK_PORT |= _BV(FSK);
     ddc:	88 e3       	ldi	r24, 0x38	; 56
     dde:	90 e0       	ldi	r25, 0x00	; 0
     de0:	28 e3       	ldi	r18, 0x38	; 56
     de2:	30 e0       	ldi	r19, 0x00	; 0
     de4:	f9 01       	movw	r30, r18
     de6:	20 81       	ld	r18, Z
     de8:	20 61       	ori	r18, 0x10	; 16
     dea:	fc 01       	movw	r30, r24
     dec:	20 83       	st	Z, r18
					break;
     dee:	0c c0       	rjmp	.+24     	; 0xe08 <main+0x952>
				case MODE_QRSS6:
				case MODE_CW:
					// Transmitter on
					tx_on();
     df0:	30 db       	rcall	.-2464   	; 0x452 <tx_on>

					// Set FSK to 0 (maximum capacitance/minimum freq)
					FSK_PORT &= ~(_BV(FSK));
     df2:	88 e3       	ldi	r24, 0x38	; 56
     df4:	90 e0       	ldi	r25, 0x00	; 0
     df6:	28 e3       	ldi	r18, 0x38	; 56
     df8:	30 e0       	ldi	r19, 0x00	; 0
     dfa:	f9 01       	movw	r30, r18
     dfc:	20 81       	ld	r18, Z
     dfe:	2f 7e       	andi	r18, 0xEF	; 239
     e00:	fc 01       	movw	r30, r24
     e02:	20 83       	st	Z, r18
					break;
     e04:	01 c0       	rjmp	.+2      	; 0xe08 <main+0x952>
				default:
					break;
     e06:	00 00       	nop
				}

				if(cur_timer > cur_state_end)
     e08:	20 91 60 00 	lds	r18, 0x0060
     e0c:	30 91 61 00 	lds	r19, 0x0061
     e10:	40 91 62 00 	lds	r20, 0x0062
     e14:	50 91 63 00 	lds	r21, 0x0063
     e18:	80 91 a7 00 	lds	r24, 0x00A7
     e1c:	90 91 a8 00 	lds	r25, 0x00A8
     e20:	a0 91 a9 00 	lds	r26, 0x00A9
     e24:	b0 91 aa 00 	lds	r27, 0x00AA
     e28:	82 17       	cp	r24, r18
     e2a:	93 07       	cpc	r25, r19
     e2c:	a4 07       	cpc	r26, r20
     e2e:	b5 07       	cpc	r27, r21
     e30:	08 f0       	brcs	.+2      	; 0xe34 <main+0x97e>
     e32:	78 c0       	rjmp	.+240    	; 0xf24 <main+0xa6e>
				{
					switch(cur_mode)
     e34:	80 91 9d 00 	lds	r24, 0x009D
     e38:	88 2f       	mov	r24, r24
     e3a:	90 e0       	ldi	r25, 0x00	; 0
     e3c:	00 97       	sbiw	r24, 0x00	; 0
     e3e:	31 f0       	breq	.+12     	; 0xe4c <main+0x996>
     e40:	99 23       	and	r25, r25
     e42:	d4 f0       	brlt	.+52     	; 0xe78 <main+0x9c2>
     e44:	83 30       	cpi	r24, 0x03	; 3
     e46:	91 05       	cpc	r25, r1
     e48:	bc f4       	brge	.+46     	; 0xe78 <main+0x9c2>
     e4a:	0b c0       	rjmp	.+22     	; 0xe62 <main+0x9ac>
					{
					case MODE_DFCW6:
						// Transmitter on
						tx_on();
     e4c:	02 db       	rcall	.-2556   	; 0x452 <tx_on>

						// Set FSK to 0 (maximum capacitance/minimum freq)
						FSK_PORT &= ~(_BV(FSK));
     e4e:	88 e3       	ldi	r24, 0x38	; 56
     e50:	90 e0       	ldi	r25, 0x00	; 0
     e52:	28 e3       	ldi	r18, 0x38	; 56
     e54:	30 e0       	ldi	r19, 0x00	; 0
     e56:	f9 01       	movw	r30, r18
     e58:	20 81       	ld	r18, Z
     e5a:	2f 7e       	andi	r18, 0xEF	; 239
     e5c:	fc 01       	movw	r30, r24
     e5e:	20 83       	st	Z, r18
						break;
     e60:	0c c0       	rjmp	.+24     	; 0xe7a <main+0x9c4>
					case MODE_QRSS6:
					case MODE_CW:
						// Transmitter off
						tx_off();
     e62:	10 db       	rcall	.-2528   	; 0x484 <tx_off>

						// Set FSK to 0 (maximum capacitance/minimum freq)
						FSK_PORT &= ~(_BV(FSK));
     e64:	88 e3       	ldi	r24, 0x38	; 56
     e66:	90 e0       	ldi	r25, 0x00	; 0
     e68:	28 e3       	ldi	r18, 0x38	; 56
     e6a:	30 e0       	ldi	r19, 0x00	; 0
     e6c:	f9 01       	movw	r30, r18
     e6e:	20 81       	ld	r18, Z
     e70:	2f 7e       	andi	r18, 0xEF	; 239
     e72:	fc 01       	movw	r30, r24
     e74:	20 83       	st	Z, r18
						break;
     e76:	01 c0       	rjmp	.+2      	; 0xe7a <main+0x9c4>
					default:
						break;
     e78:	00 00       	nop
					}

					cur_state_end = cur_timer + dit_length;
     e7a:	20 91 60 00 	lds	r18, 0x0060
     e7e:	30 91 61 00 	lds	r19, 0x0061
     e82:	40 91 62 00 	lds	r20, 0x0062
     e86:	50 91 63 00 	lds	r21, 0x0063
     e8a:	80 91 99 00 	lds	r24, 0x0099
     e8e:	90 91 9a 00 	lds	r25, 0x009A
     e92:	a0 91 9b 00 	lds	r26, 0x009B
     e96:	b0 91 9c 00 	lds	r27, 0x009C
     e9a:	82 0f       	add	r24, r18
     e9c:	93 1f       	adc	r25, r19
     e9e:	a4 1f       	adc	r26, r20
     ea0:	b5 1f       	adc	r27, r21
     ea2:	80 93 a7 00 	sts	0x00A7, r24
     ea6:	90 93 a8 00 	sts	0x00A8, r25
     eaa:	a0 93 a9 00 	sts	0x00A9, r26
     eae:	b0 93 aa 00 	sts	0x00AA, r27
					cur_state = STATE_DITDELAY;
     eb2:	83 e0       	ldi	r24, 0x03	; 3
     eb4:	80 93 a3 00 	sts	0x00A3, r24
				}
				break;
     eb8:	35 c0       	rjmp	.+106    	; 0xf24 <main+0xa6e>
			case STATE_DITDELAY:
			case STATE_DAHDELAY:
			case STATE_WORDDELAY:
			case STATE_MSGDELAY:
				FSK_PORT &= ~(_BV(FSK));
     eba:	88 e3       	ldi	r24, 0x38	; 56
     ebc:	90 e0       	ldi	r25, 0x00	; 0
     ebe:	28 e3       	ldi	r18, 0x38	; 56
     ec0:	30 e0       	ldi	r19, 0x00	; 0
     ec2:	f9 01       	movw	r30, r18
     ec4:	20 81       	ld	r18, Z
     ec6:	2f 7e       	andi	r18, 0xEF	; 239
     ec8:	fc 01       	movw	r30, r24
     eca:	20 83       	st	Z, r18

				if(cur_state == STATE_MSGDELAY || cur_mode == MODE_QRSS6 || cur_mode == MODE_CW)
     ecc:	80 91 a3 00 	lds	r24, 0x00A3
     ed0:	86 30       	cpi	r24, 0x06	; 6
     ed2:	41 f0       	breq	.+16     	; 0xee4 <main+0xa2e>
     ed4:	80 91 9d 00 	lds	r24, 0x009D
     ed8:	81 30       	cpi	r24, 0x01	; 1
     eda:	21 f0       	breq	.+8      	; 0xee4 <main+0xa2e>
     edc:	80 91 9d 00 	lds	r24, 0x009D
     ee0:	82 30       	cpi	r24, 0x02	; 2
     ee2:	11 f4       	brne	.+4      	; 0xee8 <main+0xa32>
				{
					// Transmitter off
					tx_off();
     ee4:	cf da       	rcall	.-2658   	; 0x484 <tx_off>
     ee6:	01 c0       	rjmp	.+2      	; 0xeea <main+0xa34>
				}
				else
				{
					// Transmitter on
					tx_on();
     ee8:	b4 da       	rcall	.-2712   	; 0x452 <tx_on>
				}

				if(cur_timer > cur_state_end)
     eea:	20 91 60 00 	lds	r18, 0x0060
     eee:	30 91 61 00 	lds	r19, 0x0061
     ef2:	40 91 62 00 	lds	r20, 0x0062
     ef6:	50 91 63 00 	lds	r21, 0x0063
     efa:	80 91 a7 00 	lds	r24, 0x00A7
     efe:	90 91 a8 00 	lds	r25, 0x00A8
     f02:	a0 91 a9 00 	lds	r26, 0x00A9
     f06:	b0 91 aa 00 	lds	r27, 0x00AA
     f0a:	82 17       	cp	r24, r18
     f0c:	93 07       	cpc	r25, r19
     f0e:	a4 07       	cpc	r26, r20
     f10:	b5 07       	cpc	r27, r21
     f12:	50 f4       	brcc	.+20     	; 0xf28 <main+0xa72>
					cur_state = STATE_IDLE;
     f14:	10 92 a3 00 	sts	0x00A3, r1
				break;
     f18:	07 c0       	rjmp	.+14     	; 0xf28 <main+0xa72>


			default:
				break;
     f1a:	07 c0       	rjmp	.+14     	; 0xf2a <main+0xa74>
						}

					}
				}

				break;
     f1c:	00 00       	nop
     f1e:	05 c0       	rjmp	.+10     	; 0xf2a <main+0xa74>
				// When done waiting, go back to IDLE state to start the message
				if(cur_timer > cur_state_end)
				{
					cur_state = STATE_IDLE;
				}
				break;
     f20:	00 00       	nop
     f22:	03 c0       	rjmp	.+6      	; 0xf2a <main+0xa74>
					}

					cur_state_end = cur_timer + dit_length;
					cur_state = STATE_DITDELAY;
				}
				break;
     f24:	00 00       	nop
     f26:	01 c0       	rjmp	.+2      	; 0xf2a <main+0xa74>
					tx_on();
				}

				if(cur_timer > cur_state_end)
					cur_state = STATE_IDLE;
				break;
     f28:	00 00       	nop


			default:
				break;
			}
			break;
     f2a:	55 c0       	rjmp	.+170    	; 0xfd6 <main+0xb20>

		case MODE_CAL:
			switch(cur_state)
     f2c:	80 91 a3 00 	lds	r24, 0x00A3
     f30:	88 2f       	mov	r24, r24
     f32:	90 e0       	ldi	r25, 0x00	; 0
     f34:	00 97       	sbiw	r24, 0x00	; 0
     f36:	21 f0       	breq	.+8      	; 0xf40 <main+0xa8a>
     f38:	88 30       	cpi	r24, 0x08	; 8
     f3a:	91 05       	cpc	r25, r1
     f3c:	61 f1       	breq	.+88     	; 0xf96 <main+0xae0>
     f3e:	44 c0       	rjmp	.+136    	; 0xfc8 <main+0xb12>
			{
			case STATE_IDLE:
				tx_off();
     f40:	a1 da       	rcall	.-2750   	; 0x484 <tx_off>

				// Toggle the FSK port
				FSK_PORT ^= _BV(FSK);
     f42:	88 e3       	ldi	r24, 0x38	; 56
     f44:	90 e0       	ldi	r25, 0x00	; 0
     f46:	28 e3       	ldi	r18, 0x38	; 56
     f48:	30 e0       	ldi	r19, 0x00	; 0
     f4a:	f9 01       	movw	r30, r18
     f4c:	30 81       	ld	r19, Z
     f4e:	20 e1       	ldi	r18, 0x10	; 16
     f50:	23 27       	eor	r18, r19
     f52:	fc 01       	movw	r30, r24
     f54:	20 83       	st	Z, r18

				cur_state_end = cur_timer + dit_length;
     f56:	20 91 60 00 	lds	r18, 0x0060
     f5a:	30 91 61 00 	lds	r19, 0x0061
     f5e:	40 91 62 00 	lds	r20, 0x0062
     f62:	50 91 63 00 	lds	r21, 0x0063
     f66:	80 91 99 00 	lds	r24, 0x0099
     f6a:	90 91 9a 00 	lds	r25, 0x009A
     f6e:	a0 91 9b 00 	lds	r26, 0x009B
     f72:	b0 91 9c 00 	lds	r27, 0x009C
     f76:	82 0f       	add	r24, r18
     f78:	93 1f       	adc	r25, r19
     f7a:	a4 1f       	adc	r26, r20
     f7c:	b5 1f       	adc	r27, r21
     f7e:	80 93 a7 00 	sts	0x00A7, r24
     f82:	90 93 a8 00 	sts	0x00A8, r25
     f86:	a0 93 a9 00 	sts	0x00A9, r26
     f8a:	b0 93 aa 00 	sts	0x00AA, r27
				cur_state = STATE_CAL;
     f8e:	88 e0       	ldi	r24, 0x08	; 8
     f90:	80 93 a3 00 	sts	0x00A3, r24
				break;
     f94:	1e c0       	rjmp	.+60     	; 0xfd2 <main+0xb1c>
			case STATE_CAL:
				tx_on();
     f96:	5d da       	rcall	.-2886   	; 0x452 <tx_on>

				if(cur_timer > cur_state_end)
     f98:	20 91 60 00 	lds	r18, 0x0060
     f9c:	30 91 61 00 	lds	r19, 0x0061
     fa0:	40 91 62 00 	lds	r20, 0x0062
     fa4:	50 91 63 00 	lds	r21, 0x0063
     fa8:	80 91 a7 00 	lds	r24, 0x00A7
     fac:	90 91 a8 00 	lds	r25, 0x00A8
     fb0:	a0 91 a9 00 	lds	r26, 0x00A9
     fb4:	b0 91 aa 00 	lds	r27, 0x00AA
     fb8:	82 17       	cp	r24, r18
     fba:	93 07       	cpc	r25, r19
     fbc:	a4 07       	cpc	r26, r20
     fbe:	b5 07       	cpc	r27, r21
     fc0:	38 f4       	brcc	.+14     	; 0xfd0 <main+0xb1a>
					cur_state = STATE_IDLE;
     fc2:	10 92 a3 00 	sts	0x00A3, r1
				break;
     fc6:	04 c0       	rjmp	.+8      	; 0xfd0 <main+0xb1a>
			default:
				cur_state = STATE_CAL;
     fc8:	88 e0       	ldi	r24, 0x08	; 8
     fca:	80 93 a3 00 	sts	0x00A3, r24
				break;
     fce:	01 c0       	rjmp	.+2      	; 0xfd2 <main+0xb1c>
			case STATE_CAL:
				tx_on();

				if(cur_timer > cur_state_end)
					cur_state = STATE_IDLE;
				break;
     fd0:	00 00       	nop
			default:
				cur_state = STATE_CAL;
				break;
			}
			break;
     fd2:	01 c0       	rjmp	.+2      	; 0xfd6 <main+0xb20>
		default:
			// Switch to a default mode???
			break;
     fd4:	00 00       	nop
		}
	}
     fd6:	70 cb       	rjmp	.-2336   	; 0x6b8 <main+0x202>

00000fd8 <__mulsi3>:
     fd8:	ff 27       	eor	r31, r31
     fda:	ee 27       	eor	r30, r30
     fdc:	bb 27       	eor	r27, r27
     fde:	aa 27       	eor	r26, r26

00000fe0 <__mulsi3_loop>:
     fe0:	60 ff       	sbrs	r22, 0
     fe2:	04 c0       	rjmp	.+8      	; 0xfec <__mulsi3_skip1>
     fe4:	a2 0f       	add	r26, r18
     fe6:	b3 1f       	adc	r27, r19
     fe8:	e4 1f       	adc	r30, r20
     fea:	f5 1f       	adc	r31, r21

00000fec <__mulsi3_skip1>:
     fec:	22 0f       	add	r18, r18
     fee:	33 1f       	adc	r19, r19
     ff0:	44 1f       	adc	r20, r20
     ff2:	55 1f       	adc	r21, r21
     ff4:	96 95       	lsr	r25
     ff6:	87 95       	ror	r24
     ff8:	77 95       	ror	r23
     ffa:	67 95       	ror	r22
     ffc:	89 f7       	brne	.-30     	; 0xfe0 <__mulsi3_loop>
     ffe:	00 97       	sbiw	r24, 0x00	; 0
    1000:	76 07       	cpc	r23, r22
    1002:	71 f7       	brne	.-36     	; 0xfe0 <__mulsi3_loop>

00001004 <__mulsi3_exit>:
    1004:	cf 01       	movw	r24, r30
    1006:	bd 01       	movw	r22, r26
    1008:	08 95       	ret

0000100a <__udivmodsi4>:
    100a:	a1 e2       	ldi	r26, 0x21	; 33
    100c:	1a 2e       	mov	r1, r26
    100e:	aa 1b       	sub	r26, r26
    1010:	bb 1b       	sub	r27, r27
    1012:	fd 01       	movw	r30, r26
    1014:	0d c0       	rjmp	.+26     	; 0x1030 <__udivmodsi4_ep>

00001016 <__udivmodsi4_loop>:
    1016:	aa 1f       	adc	r26, r26
    1018:	bb 1f       	adc	r27, r27
    101a:	ee 1f       	adc	r30, r30
    101c:	ff 1f       	adc	r31, r31
    101e:	a2 17       	cp	r26, r18
    1020:	b3 07       	cpc	r27, r19
    1022:	e4 07       	cpc	r30, r20
    1024:	f5 07       	cpc	r31, r21
    1026:	20 f0       	brcs	.+8      	; 0x1030 <__udivmodsi4_ep>
    1028:	a2 1b       	sub	r26, r18
    102a:	b3 0b       	sbc	r27, r19
    102c:	e4 0b       	sbc	r30, r20
    102e:	f5 0b       	sbc	r31, r21

00001030 <__udivmodsi4_ep>:
    1030:	66 1f       	adc	r22, r22
    1032:	77 1f       	adc	r23, r23
    1034:	88 1f       	adc	r24, r24
    1036:	99 1f       	adc	r25, r25
    1038:	1a 94       	dec	r1
    103a:	69 f7       	brne	.-38     	; 0x1016 <__udivmodsi4_loop>
    103c:	60 95       	com	r22
    103e:	70 95       	com	r23
    1040:	80 95       	com	r24
    1042:	90 95       	com	r25
    1044:	9b 01       	movw	r18, r22
    1046:	ac 01       	movw	r20, r24
    1048:	bd 01       	movw	r22, r26
    104a:	cf 01       	movw	r24, r30
    104c:	08 95       	ret

0000104e <memset>:
    104e:	dc 01       	movw	r26, r24
    1050:	01 c0       	rjmp	.+2      	; 0x1054 <memset+0x6>
    1052:	6d 93       	st	X+, r22
    1054:	41 50       	subi	r20, 0x01	; 1
    1056:	50 40       	sbci	r21, 0x00	; 0
    1058:	e0 f7       	brcc	.-8      	; 0x1052 <memset+0x4>
    105a:	08 95       	ret

0000105c <__eerd_block_tn45>:
    105c:	dc 01       	movw	r26, r24
    105e:	86 2f       	mov	r24, r22

00001060 <__eerd_blraw_tn45>:
    1060:	e8 2f       	mov	r30, r24
    1062:	e1 99       	sbic	0x1c, 1	; 28
    1064:	fe cf       	rjmp	.-4      	; 0x1062 <__eerd_blraw_tn45+0x2>
    1066:	1f ba       	out	0x1f, r1	; 31
    1068:	05 c0       	rjmp	.+10     	; 0x1074 <__eerd_blraw_tn45+0x14>
    106a:	ee bb       	out	0x1e, r30	; 30
    106c:	e0 9a       	sbi	0x1c, 0	; 28
    106e:	e3 95       	inc	r30
    1070:	0d b2       	in	r0, 0x1d	; 29
    1072:	0d 92       	st	X+, r0
    1074:	41 50       	subi	r20, 0x01	; 1
    1076:	c8 f7       	brcc	.-14     	; 0x106a <__eerd_blraw_tn45+0xa>
    1078:	08 95       	ret

0000107a <__eerd_word_tn45>:
    107a:	a8 e1       	ldi	r26, 0x18	; 24
    107c:	b0 e0       	ldi	r27, 0x00	; 0
    107e:	42 e0       	ldi	r20, 0x02	; 2
    1080:	ef cf       	rjmp	.-34     	; 0x1060 <__eerd_blraw_tn45>

00001082 <_exit>:
    1082:	f8 94       	cli

00001084 <__stop_program>:
    1084:	ff cf       	rjmp	.-2      	; 0x1084 <__stop_program>
